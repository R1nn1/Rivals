local ArrayField = loadstring(game:HttpGet("https://raw.githubusercontent.com/Hosvile/Refinement/main/MC%3AArrayfield%20Library"))()

if not ArrayField then
    error("Failed to load ArrayField library")
end

local Window = ArrayField:CreateWindow({
    Name = "Rinns Hub Rivals",
    LoadingTitle = "Rinns Hub Rivals",
    LoadingSubtitle = "Code By Rinn Ui by Sirius Ui remake by Hosvile",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "RinnsHubConfigs",
        FileName = "RinnsHubRivals"
    },
    Discord = {
        Enabled = true,
        Invite = "pzZTWgkUgE",
        RememberJoins = false
    },
    KeySystem = false,
    KeySettings = {
        Title = "ArrayField",
        Subtitle = "Key System",
        Note = "Join the discord (discord.gg/sirius)",
        FileName = "ArrayFieldsKeys",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {"Hello", "Bye"},
        Actions = {
            [1] = {
                Text = 'Click here to copy the key link',
                OnPress = function() end,
            }
        },
    }
})

local Tab = Window:CreateTab("Main Tab", 4483362458)

-- Aimbot settings
local aimbotEnabled = false
local wallCheckEnabled = false
local aimbotFov = 175
local fovTransparency = 0.4
local fovThickness = 2
local lockOnRange = 3000
local fovCircle = nil
local aimPart = "Head"
local fovFollowMouse = false
local players = game:GetService("Players")
local camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local wishlistedUsers = {}
local wishlistFriends = false
local fovCircleColor = Color3.new(1, 1, 1)

local function createFovCircle()
    if fovCircle then fovCircle:Remove() end
    fovCircle = Drawing.new("Circle")
    fovCircle.Thickness = fovThickness
    fovCircle.NumSides = 64
    fovCircle.Radius = aimbotFov
    fovCircle.Color = fovCircleColor
    fovCircle.Transparency = fovTransparency
    fovCircle.Visible = aimbotEnabled
end

local function updateFovCircle()
    if fovCircle then
        fovCircle.Position = fovFollowMouse and UserInputService:GetMouseLocation() or Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
        fovCircle.Radius = aimbotFov
        fovCircle.Color = fovCircleColor
        fovCircle.Transparency = fovTransparency
        fovCircle.Thickness = fovThickness
        fovCircle.Visible = aimbotEnabled
    end
end

local function isPlayerVisible(target)
    local origin = camera.CFrame.Position
    local _, onScreen = camera:WorldToScreenPoint(target.Position)
    if not onScreen then
        return false
    end

    local ray = Ray.new(origin, (target.Position - origin).unit * lockOnRange)
    local part, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, {camera, players.LocalPlayer.Character})
    if part and part:IsDescendantOf(target.Parent) then
        return true
    end

    return false
end

local function isUserWishlisted(username)
    for _, user in pairs(wishlistedUsers) do
        if string.find(string.lower(username), string.lower(user)) then
            return true
        end
    end
    return false
end

local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(players:GetPlayers()) do
        if player ~= players.LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            local humanoid = player.Character.Humanoid

            if humanoid.Health > 0 and not isUserWishlisted(player.Name) then
                local screenPoint = camera:WorldToScreenPoint(hrp.Position)
                local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - (fovFollowMouse and UserInputService:GetMouseLocation() or Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2))).Magnitude

                if distanceFromCenter <= aimbotFov and (not wallCheckEnabled or isPlayerVisible(hrp)) then
                    local distance = (hrp.Position - players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimAtClosestPlayer()
    if aimbotEnabled then
        local closestPlayer = getClosestPlayer()
        if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild(aimPart) then
            local target = closestPlayer.Character[aimPart]
            local targetPosition = target.Position
            local currentCameraPosition = camera.CFrame.Position
            local direction = (targetPosition - currentCameraPosition).unit
            local targetCameraCFrame = CFrame.new(currentCameraPosition, currentCameraPosition + direction)
            camera.CFrame = targetCameraCFrame
        end
    end
end

RunService.RenderStepped:Connect(function()
    updateFovCircle()
    aimAtClosestPlayer()
end)

-- Aimbot UI
Tab:CreateToggle({
    Name = "Aimbot",
    Info = {
        Title = 'Enable or Disable Aimbot',
        Description = 'Dont feel like typing all that but remember Dont hold fire spam the fire button',
    },
    CurrentValue = aimbotEnabled,
    Flag = "AimbotToggle",
    Callback = function(Value)
        aimbotEnabled = Value
        updateFovCircle()
    end,
})

Tab:CreateToggle({
    Name = "Aimbot Wall Check",
    Info = {
        Title = 'Enable or Disable Wall Check',
        Description = 'Checks If the person the aimbot is trying to lock on is behind a way and wont lock on to them',
    },
    CurrentValue = wallCheckEnabled,
    Flag = "WallCheckToggle",
    Callback = function(Value)
        wallCheckEnabled = Value
    end,
})

Tab:CreateToggle({
    Name = "Aimbot Fov Follow Mouse",
    Info = {
        Title = 'Enable or Disable Aimbot Fov Follow Mouse',
        Description = 'Makes It so the Aimbot Fov follows your Mouse Dont Use This For Mobile',
    },
    CurrentValue = fovFollowMouse,
    Flag = "FovFollowMouseToggle",
    Callback = function(Value)
        fovFollowMouse = Value
        updateFovCircle()
    end,
})

Tab:CreateSpacing(nil,5)

Tab:CreateSlider({
    Name = "Aimbot Fov Size",
    Info = {
        Title = 'Change The Aimbot Fov Size',
        Description = 'Lets you change the size of the aimbot Fov',
    },
    Range = {1, 1000},
    Increment = 1,
    Suffix = "Studs",
    CurrentValue = aimbotFov,
    Flag = "AimbotFovSlider",
    Callback = function(Value)
        aimbotFov = Value
        updateFovCircle()
    end,
})

Tab:CreateSlider({
    Name = "Aimbot Fov Transparency",
    Info = {
        Title = 'Change The Aimbot Fov Transparency',
        Description = 'Lets you change the transparency of the aimbot Fov',
    },
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = fovTransparency,
    Flag = "AimbotFovTransparencySlider",
    Callback = function(Value)
        fovTransparency = Value
        updateFovCircle()
    end,
})

print("testing1")
Tab:CreateSlider({
    Name = "Aimbot Fov Thickness",
    Info = {
        Title = 'Change The Aimbot Fov Thickness',
        Description = 'Lets you change the thickness of the aimbot Fov',
    },
    Range = {1, 10},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = fovThickness,
    Flag = "AimbotFovThicknessSlider",
    Callback = function(Value)
        fovThickness = Value
        updateFovCircle()
    end,
})

print("testing2")

Tab:CreateDropdown({
    Name = "Aimbot Aim Part",
    Info = {
        Title = 'Change The Aimbot Aim Part',
        Description = 'Lets you change the part of the target the aimbot aims at',
    },
    Options = {"Head", "Torso", "HumanoidRootPart"},
    CurrentOption = aimPart,
    Flag = "AimbotAimPartDropdown",
    Callback = function(Value)
        aimPart = Value
    end,
})

Tab:CreateSlider({
    Name = "Aimbot Lock On Range",
    Info = {
        Title = 'Change The Aimbot Lock On Range',
        Description = 'Lets you change the range at which the aimbot locks on to targets',
    },
    Range = {100, 10000},
    Increment = 1,
    Suffix = "Studs",
    CurrentValue = lockOnRange,
    Flag = "AimbotLockOnRangeSlider",
    Callback = function(Value)
        lockOnRange = Value
    end,
})

print("testing 3")

Tab:CreateKeybind({
    Name = "Aimbot Toggle Keybind",
    CurrentKeybind = "Q",
    HoldToInteract = false,
    Flag = "AimbotKeybind",
    Callback = function(Keybind)
        aimbotEnabled = not aimbotEnabled
        updateFovCircle()
    end,
})

-- Initialize FOV circle
createFovCircle()
print("testing4")

Tab:CreateSpacing(nil,10)

Tab:CreateToggle({
    Name = "Wishlist Friends",
    Info = {
        Title = 'Wishlist Friends',
        Description = 'Toggle this on to wishlist friends.',
    },
    CurrentValue = wishlistFriends,
    Flag = "WishlistFriendsToggle",
    Callback = function(Value)
        wishlistFriends = Value
        if wishlistFriends then
            wishlistedUsers = {}
            local success, result = pcall(function()
                return players:GetFriendsAsync(players.LocalPlayer.UserId)
            end)
            if success then
                for _, friend in pairs(result) do
                    for _, player in pairs(players:GetPlayers()) do
                        if player.Name == friend.Username then
                            table.insert(wishlistedUsers, friend.Username)
                        end
                    end
                end
            else
                print("Error fetching friends:", result)
            end
        end
    end,
})

Tab:CreateButton({
    Name = "Clear Wishlist",
    Info = {
        Title = 'Clear Wishlist',
        Description = 'Clears all users from the wishlist.',
    },
    Callback = function()
        wishlistedUsers = {}
    end,
})

-- Function to find the closest match for a username
local function findClosestUsername(input)
    local closestUsername = nil
    local closestDistance = math.huge

    for _, player in pairs(players:GetPlayers()) do
        local lowerInput = string.lower(input)
        local lowerName = string.lower(player.Name)
        local _, matches = string.gsub(lowerName, lowerInput, "")
        local distance = #lowerInput + #lowerName - 2 * matches
        if matches > 0 and distance < closestDistance then
            closestDistance = distance
            closestUsername = player.Name
        end
    end

    return closestUsername
end

-- Update wishlist to store closest matching usernames
Tab:CreateInput({
    Name = "Wishlist Users",
    PlaceholderText = "Put UserNames to wishlist Here",
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        wishlistedUsers = {}
        local userInput = string.split(Text, ",")
        for _, user in pairs(userInput) do
            user = user:match("^%s*(.-)%s*$") -- trim whitespace
            if user ~= "" then
                local closestMatch = findClosestUsername(user)
                if closestMatch then
                    table.insert(wishlistedUsers, closestMatch)
                end
            end
        end
    end,
})


Tab:CreateSpacing(nil, 10)

local AutoVoteMap = false
local selectedOption = "Arena"
local randomExecutor

-- Define the map actions
local mapActions = {
    ["Onyx"] = function()
        local args = { [1] = "Onyx" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Onyx")
    end,
    ["Construction"] = function()
        local args = { [1] = "Construction" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Construction")
    end,
    ["Shooting Range"] = function()
        local args = { [1] = "Shooting Range" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Shooting Range")
    end,
    ["Docks"] = function()
        local args = { [1] = "Docks" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Docks")
    end,
    ["Crossroads"] = function()
        local args = { [1] = "Crossroads" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Crossroads")
    end,
    ["Station"] = function()
        local args = { [1] = "Station" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Station")
    end,
    ["Big Crossroads"] = function()
        local args = { [1] = "Big Crossroads" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Big Crossroads")
    end,
    ["Backrooms"] = function()
        local args = { [1] = "Backrooms" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Backrooms")
    end,
    ["Arena"] = function()
        local args = { [1] = "Arena" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Arena")
    end,
}

-- Create the toggle for Auto Vote Map
Tab:CreateToggle({
    Name = "Auto Vote Map",
    Info = {
        Title = 'Auto Vote Map',
        Image = '12735851647',
        Description = 'Automatically votes the selected map in the dropdown below for you',
    },
    CurrentValue = false,
    Flag = "AutoVote", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        AutoVoteMap = Value
        if AutoVoteMap then
            print("Auto Vote Map enabled")
        else
            print("Auto Vote Map disabled")
        end
    end,
})

-- Create the dropdown for map selection
Tab:CreateDropdown({
    Name = "Map Selector",
    Options = {"Onyx", "Construction", "Shooting Range", "Docks", "Crossroads", "Station", "Big Crossroads", "Backrooms", "Arena"},
    CurrentOption = "Arena",
    MultiSelection = false,
    Flag = "MapDropDown",
    Callback = function(Option)
        selectedOption = Option
        print("Selected map: " .. Option)
    end,
})

local EspTab = Window:CreateTab("Esp Tab", 4483362458)

local boxes = {}
local names = {}
local distances = {}
local healthBars = {}
local healthTexts = {}
local connections = {}

local function createBox(player)
    if player == game:GetService("Players").LocalPlayer then return end

    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Transparency = 1
    box.Color = Color3.new(1, 1, 1)
    box.Filled = false
    box.Outline = true
    box.OutlineColor = Color3.new(0, 0, 0)
    boxes[player] = box

    if nameEspEnabled then
        local name = Drawing.new("Text")
        name.Size = 10
        name.Color = Color3.new(1, 1, 1)
        name.Center = true
        name.Outline = true
        name.OutlineColor = Color3.new(0, 0, 0)
        name.Text = player.Name
        names[player] = name
    end

    if distanceEspEnabled then
        local distance = Drawing.new("Text")
        distance.Size = 10
        distance.Color = Color3.new(1, 1, 1)
        distance.Center = true
        distance.Outline = true
        distance.OutlineColor = Color3.new(0, 0, 0)
        distances[player] = distance
    end

    if healthBarEspEnabled then
        local healthBar = Drawing.new("Square")
        healthBar.Thickness = 1
        healthBar.Transparency = 1
        healthBar.Color = Color3.new(0, 0, 0)
        healthBar.Filled = false

        local healthBarGreen = Drawing.new("Square")
        healthBarGreen.Thickness = 0
        healthBarGreen.Transparency = 1
        healthBarGreen.Color = Color3.new(0, 1, 0)
        healthBarGreen.Filled = true

        local healthBarRed = Drawing.new("Square")
        healthBarRed.Thickness = 0
        healthBarRed.Transparency = 1
        healthBarRed.Color = Color3.new(1, 0, 0)
        healthBarRed.Filled = true

        healthBars[player] = {healthBar, healthBarGreen, healthBarRed}
    end

    if healthTextEspEnabled then
        local healthText = Drawing.new("Text")
        healthText.Size = 10
        healthText.Color = Color3.new(1, 1, 1)
        healthText.Center = true
        healthText.Outline = true
        healthText.OutlineColor = Color3.new(0, 0, 0)
        healthTexts[player] = healthText
    end
end

local function removeBox(player)
    if boxes[player] then
        boxes[player]:Remove()
        boxes[player] = nil
    end
    if names[player] then
        names[player]:Remove()
        names[player] = nil
    end
    if distances[player] then
        distances[player]:Remove()
        distances[player] = nil
    end
    if healthBars[player] then
        healthBars[player][1]:Remove()
        healthBars[player][2]:Remove()
        healthBars[player][3]:Remove()
        healthBars[player] = nil
    end
    if healthTexts[player] then
        healthTexts[player]:Remove()
        healthTexts[player] = nil
    end
end

local function updateBoxes()
    for player, box in pairs(boxes) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            local vector, onScreen = game.Workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                box.Visible = true
                local scaleFactor = 0.5 / (vector.Z / 100)
                box.Size = Vector2.new(20 * scaleFactor, 35 * scaleFactor)
                box.Position = Vector2.new(vector.X - 10 * scaleFactor, vector.Y - 17.5 * scaleFactor)

                if names[player] then
                    names[player].Visible = true
                    names[player].Position = Vector2.new(vector.X, vector.Y - 20 * scaleFactor)
                end

                if distances[player] then
                    distances[player].Visible = true
                    local distance = (game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                    distances[player].Text = string.format("%.0f studs", distance)
                    distances[player].Position = Vector2.new(vector.X, vector.Y + 20 * scaleFactor)
                end

                if healthBars[player] then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        local health = humanoid.Health
                        local maxHealth = humanoid.MaxHealth
                        local healthPercent = health / maxHealth

                        local healthBar = healthBars[player][1]
                        local healthBarGreen = healthBars[player][2]
                        local healthBarRed = healthBars[player][3]

                        healthBar.Visible = true
                        healthBarGreen.Visible = true
                        healthBarRed.Visible = true

                        healthBar.Size = Vector2.new(3 * scaleFactor, 35 * scaleFactor)
                        healthBar.Position = Vector2.new(vector.X - 13 * scaleFactor, vector.Y - 17.5 * scaleFactor)

                        healthBarGreen.Size = Vector2.new(3 * scaleFactor, 35 * scaleFactor * healthPercent)
                        healthBarGreen.Position = Vector2.new(vector.X - 13 * scaleFactor, vector.Y - 17.5 * scaleFactor + (35 * scaleFactor * (1 - healthPercent)))

                        healthBarRed.Size = Vector2.new(3 * scaleFactor, 35 * scaleFactor * (1 - healthPercent))
                        healthBarRed.Position = Vector2.new(vector.X - 13 * scaleFactor, vector.Y - 17.5 * scaleFactor)
                    else
                        healthBars[player][1].Visible = false
                        healthBars[player][2].Visible = false
                        healthBars[player][3].Visible = false
                    end
                end

                if healthTexts[player] then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        local health = humanoid.Health
                        local maxHealth = humanoid.MaxHealth

                        healthTexts[player].Visible = true
                        healthTexts[player].Text = string.format("%.0f / %.0f", health, maxHealth)
                        healthTexts[player].Position = Vector2.new(vector.X + 15 * scaleFactor, vector.Y)
                    else
                        healthTexts[player].Visible = false
                    end
                end
            else
                box.Visible = false
                if names[player] then
                    names[player].Visible = false
                end
                if distances[player] then
                    distances[player].Visible = false
                end
                if healthBars[player] then
                    healthBars[player][1].Visible = false
                    healthBars[player][2].Visible = false
                    healthBars[player][3].Visible = false
                end
                if healthTexts[player] then
                    healthTexts[player].Visible = false
                end
            end
        else
            box.Visible = false
            if names[player] then
                names[player].Visible = false
            end
            if distances[player] then
                distances[player].Visible = false
            end
            if healthBars[player] then
                healthBars[player][1].Visible = false
                healthBars[player][2].Visible = false
                healthBars[player][3].Visible = false
            end
            if healthTexts[player] then
                healthTexts[player].Visible = false
            end
        end
    end
end

local function playerAdded(player)
    player.CharacterAdded:Connect(function()
        createBox(player)
    end)

    player.CharacterRemoving:Connect(function()
        removeBox(player)
    end)

    -- Create ESP for the character if it exists
    if player.Character then
        createBox(player)
    end
end

local function toggleBoxESP(enabled)
    if enabled then
        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            playerAdded(player)
        end
        connections.renderStepped = game:GetService("RunService").RenderStepped:Connect(updateBoxes)
    else
        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            removeBox(player)
        end
        if connections.renderStepped then
            connections.renderStepped:Disconnect()
            connections.renderStepped = nil
        end
    end
end

local function toggleNameESP(enabled)
    nameEspEnabled = enabled
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if enabled then
            if not names[player] then
                local name = Drawing.new("Text")
                name.Size = 10
                name.Color = Color3.new(1, 1, 1)
                name.Center = true
                name.Outline = true
                name.OutlineColor = Color3.new(0, 0, 0)
                name.Text = player.Name
                names[player] = name
            end
        else
            if names[player] then
                names[player]:Remove()
                names[player] = nil
            end
        end
    end
end

local function toggleDistanceESP(enabled)
    distanceEspEnabled = enabled
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if enabled then
            if not distances[player] then
                local distance = Drawing.new("Text")
                distance.Size = 10
                distance.Color = Color3.new(1, 1, 1)
                distance.Center = true
                distance.Outline = true
                distance.OutlineColor = Color3.new(0, 0, 0)
                distances[player] = distance
            end
        else
            if distances[player] then
                distances[player]:Remove()
                distances[player] = nil
            end
        end
    end
end

local function toggleHealthBarESP(enabled)
    healthBarEspEnabled = enabled
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if enabled then
            if not healthBars[player] then
                local healthBar = Drawing.new("Square")
                healthBar.Thickness = 1
                healthBar.Transparency = 1
                healthBar.Color = Color3.new(0, 0, 0)
                healthBar.Filled = false

                local healthBarGreen = Drawing.new("Square")
                healthBarGreen.Thickness = 0
                healthBarGreen.Transparency = 1
                healthBarGreen.Color = Color3.new(0, 1, 0)
                healthBarGreen.Filled = true

                local healthBarRed = Drawing.new("Square")
                healthBarRed.Thickness = 0
                healthBarRed.Transparency = 1
                healthBarRed.Color = Color3.new(1, 0, 0)
                healthBarRed.Filled = true

                healthBars[player] = {healthBar, healthBarGreen, healthBarRed}
            end
        else
            if healthBars[player] then
                healthBars[player][1]:Remove()
                healthBars[player][2]:Remove()
                healthBars[player][3]:Remove()
                healthBars[player] = nil
            end
        end
    end
end

local function toggleHealthTextESP(enabled)
    healthTextEspEnabled = enabled
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if enabled then
            if not healthTexts[player] then
                local healthText = Drawing.new("Text")
                healthText.Size = 10
                healthText.Color = Color3.new(1, 1, 1)
                healthText.Center = true
                healthText.Outline = true
                healthText.OutlineColor = Color3.new(0, 0, 0)
                healthTexts[player] = healthText
            end
        else
            if healthTexts[player] then
                healthTexts[player]:Remove()
                healthTexts[player] = nil
            end
        end
    end
end

game:GetService("Players").PlayerAdded:Connect(playerAdded)
game:GetService("Players").PlayerRemoving:Connect(removeBox)

EspTab:CreateToggle({
    Name = "Box Esp",
    Default = false,
    Callback = function(value)
        toggleBoxESP(value)
    end
})

EspTab:CreateToggle({
    Name = "Name esp",
    Default = false,
    Callback = function(value)
        toggleNameESP(value)
    end
})

EspTab:CreateToggle({
    Name = "Distance esp",
    Default = false,
    Callback = function(value)
        toggleDistanceESP(value)
    end
})

EspTab:CreateToggle({
    Name = "Health Bar esp",
    Default = false,
    Callback = function(value)
        toggleHealthBarESP(value)
    end
})

EspTab:CreateToggle({
    Name = "Health Text esp",
    Default = false,
    Callback = function(value)
        toggleHealthTextESP(value)
    end
})

local MiscTab = Window:CreateTab("Misc Tab", 4483362458) -- Title, Image

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local function rotateMouse(rotationSpeed)
    local playerName = Players.LocalPlayer.Name
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    local mainGui = playerGui:WaitForChild("MainGui")
    local mainFrame = mainGui:WaitForChild("MainFrame")
    local itemInterfaces = mainFrame:WaitForChild("ItemInterfaces")

    for _, item in pairs(itemInterfaces:GetChildren()) do
        if item.Name:find(playerName) then
            local mouse = item:FindFirstChild("Mouse")
            if mouse then
                RunService.RenderStepped:Connect(function()
                    mouse.Rotation = mouse.Rotation + rotationSpeed
                end)
            end
        end
    end
end

local rotationSpeed = 1
local rotationConnection

MiscTab:CreateToggle({
    Name = "Rotating Crosshair",
    Info = {
        Title = 'Makes Your Crosshair Rotate',
        Image = '12735851647',
        Description = 'so cool',
    },
    CurrentValue = false,
    Flag = "CrossHairRotate", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value then
            rotationConnection = RunService.RenderStepped:Connect(function()
                rotateMouse(rotationSpeed)
            end)
        else
            if rotationConnection then
                rotationConnection:Disconnect()
            end
        end
    end,
})

MiscTab:CreateSlider({
    Name = "Rotation Speed",
    Range = {0, 10},
    Increment = 0.1,
    Suffix = "Speed",
    CurrentValue = 1,
    Flag = "RotateSpeed",
    Callback = function(Value)
        rotationSpeed = Value
    end,
})

local PlayerTab = Window:CreateTab("Players Tab", 4483362458) -- Title, Image

PlayerTab:CreateSpacing(nil, 10)

local enableLongJump = false
local enableScytheDash = false
local enableClickTeleport = false

local function createLongJumpButton()
    if game.CoreGui:FindFirstChild("LongJumpGui") then
        return
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "LongJumpGui"
    screenGui.Parent = game.CoreGui

    local longJumpButton = Instance.new("TextButton")
    longJumpButton.Size = UDim2.new(0, 50, 0, 50)
    longJumpButton.Position = UDim2.new(1, -60, 0.5, -25)
    longJumpButton.Text = "Jump"
    longJumpButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    longJumpButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    longJumpButton.BackgroundTransparency = 0.5

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(1, 0)
    uiCorner.Parent = longJumpButton

    longJumpButton.Draggable = true
    longJumpButton.Active = true

    longJumpButton.MouseButton1Click:Connect(function()
        if enableLongJump then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame * CFrame.new(0, 50, 0)}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end)

    longJumpButton.Parent = screenGui
end

local function createScytheDashButton()
    if game.CoreGui:FindFirstChild("ScytheDashGui") then
        return
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ScytheDashGui"
    screenGui.Parent = game.CoreGui

    local scytheDashButton = Instance.new("TextButton")
    scytheDashButton.Size = UDim2.new(0, 50, 0, 50)
    scytheDashButton.Position = UDim2.new(0, 10, 0.5, -25)
    scytheDashButton.Text = "Dash"
    scytheDashButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    scytheDashButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    scytheDashButton.BackgroundTransparency = 0.5

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(1, 0)
    uiCorner.Parent = scytheDashButton

    scytheDashButton.Draggable = true
    scytheDashButton.Active = true

    local function dash()
        if enableScytheDash then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if rootPart and humanoid then
                    local camera = workspace.CurrentCamera
                    local lookVector = camera.CFrame.LookVector
                    local dashDirection = lookVector.Unit * 30 -- Ensure the lookVector is normalized
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame + dashDirection}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end

    scytheDashButton.MouseButton1Click:Connect(dash)

    scytheDashButton.Parent = screenGui
end

local function enableClickTeleportFunction()
    local player = game:GetService("Players").LocalPlayer
    local mouse = player:GetMouse()
    
    mouse.Button1Down:Connect(function()
        if enableClickTeleport then
            local character = player.Character or player.CharacterAdded:Wait()
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                rootPart.CFrame = CFrame.new(mouse.Hit.p + Vector3.new(0, 3, 0))
            end
        end
    end)
end

PlayerTab:CreateToggle({
    Name = "Enable Fake Scythe Dash",
    Info = {
        Title = 'Enable Fake Scythe Dash',
        Image = '12735851647',
        Description = 'Enables the Fake Scythe Dash action',
    },
    CurrentValue = false,
    Flag = "EnableScytheDash", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        enableScytheDash = Value
    end,
})

PlayerTab:CreateToggle({
    Name = "Show Fake Scythe Dash Button",
    Info = {
        Title = 'Show Fake Scythe Dash Button',
        Image = '12735851647',
        Description = 'Shows the Fake Scythe Dash button',
    },
    CurrentValue = false,
    Flag = "ShowScytheDashButton", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value then
            createScytheDashButton()
        else
            local gui = game.CoreGui:FindFirstChild("ScytheDashGui")
            if gui then
                gui:Destroy()
            end
        end
        print(Value)
    end,
})

PlayerTab:CreateKeybind({
    Name = "Fake Scythe Dash Keybind",
    CurrentKeybind = "E",
    HoldToInteract = false,
    Flag = "ScytheDashKeybind",
    Callback = function(Keybind)
        if enableScytheDash then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if rootPart and humanoid then
                    local camera = workspace.CurrentCamera
                    local lookVector = camera.CFrame.LookVector
                    local dashDirection = lookVector.Unit * 30 -- Ensure the lookVector is normalized
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame + dashDirection}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end,
})

PlayerTab:CreateSpacing(nil, 10)

PlayerTab:CreateToggle({
    Name = "Enable Long Jump",
    Info = {
        Title = 'Enable Long Jump',
        Image = '12735851647',
        Description = 'Enables the Long Jump action',
    },
    CurrentValue = false,
    Flag = "EnableLongJump", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        enableLongJump = Value
    end,
})

PlayerTab:CreateToggle({
    Name = "Show Long Jump Button",
    Info = {
        Title = 'Show Long Jump Button',
        Image = '12735851647',
        Description = 'Shows the Long Jump button',
    },
    CurrentValue = false,
    Flag = "ShowLongJumpButton", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value then
            createLongJumpButton()
        else
            local gui = game.CoreGui:FindFirstChild("LongJumpGui")
            if gui then
                gui:Destroy()
            end
        end
        print(Value)
    end,
})

PlayerTab:CreateKeybind({
    Name = "Long Jump Keybind",
    CurrentKeybind = "Q",
    HoldToInteract = false,
    Flag = "LongJumpKeybind",
    Callback = function(Keybind)
        if enableLongJump then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame * CFrame.new(0, 50, 0)}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end,
})

PlayerTab:CreateToggle({
    Name = "Enable Click Teleport",
    Info = {
        Title = 'Enable Click Teleport',
        Image = '12735851647',
        Description = 'Enables the Click Teleport action',
    },
    CurrentValue = false,
    Flag = "EnableClickTeleport", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        enableClickTeleport = Value
        if enableClickTeleport then
            enableClickTeleportFunction()
        end
    end,
})

PlayerTab:CreateSlider({
    Name = "WalkSpeed",
    Range = {0, 500},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Flag = "WalkSpeedSlider",
    Callback = function(Value)
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = Value
        end
    end,
})

PlayerTab:CreateSlider({
    Name = "JumpPower",
    Range = {16, 500},
    Increment = 1,
    Suffix = "Power",
    CurrentValue = 50,
    Flag = "JumpPowerSlider",
    Callback = function(Value)
        local player = game:GetService("Players").LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.JumpPower = Value
        end
    end,
})

function reduceLag()
    -- Lower rendering quality level
    settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    
    -- Terrain settings
    Workspace.Terrain.WaterWaveSize = 0
    Workspace.Terrain.WaterWaveSpeed = 0
    Workspace.Terrain.WaterReflectance = 0
    Workspace.Terrain.WaterTransparency = 0
    
    -- Adjusting properties of parts
    for _, v in pairs(Workspace:GetDescendants()) do
        if v:IsA("Part") or v:IsA("UnionOperation") or v:IsA("MeshPart") or v:IsA("WedgePart") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
            v.Material = Enum.Material.Plastic
            v.Reflectance = 0
            v.CastShadow = false  -- Disable shadows
        elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
            v.Enabled = false  -- Disable particle emitters
        end
    end
    
    -- Lower graphics settings
    game.Lighting.GlobalShadows = false
    game.Lighting.FogEnd = 100000  -- Max fog distance
    
    -- Reduce render distance
    game.Players.LocalPlayer.CameraMaxZoomDistance = 50  -- Example value, adjust as needed
    
    print('Lag')
end

-- Button setup
MiscTab:CreateButton({
    Name = "Reduce Lag",
    Info = {
        Title = 'Less Lag',
        Description = 'reduces lag in the game.',
    },
    Interact = 'Changable',
    Callback = function()
        reduceLag()
    end,
})


ArrayField:Notify({
   Title = "Aimbot Wishlisting",
   Content = "The Aimbot Wont Lock On To Wishlisted Users put a comma to show different users",
   Duration = 9,
   Image = 4483362458,
   Actions = { -- Notification Buttons
      Ignore = {
         Name = "Okay!",
         Callback = function()
         print("The user tapped Okay!")
      end
   },
 },
})

print("Script loaded successfully")
ArrayField:LoadConfiguration()
