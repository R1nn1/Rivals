local ArrayField = loadstring(game:HttpGet("https://raw.githubusercontent.com/Hosvile/Refinement/main/MC%3AArrayfield%20Library"))()

local Window = ArrayField:CreateWindow({
    Name = "Rinns Hub Rivals",
    LoadingTitle = "Rinns Hub Rivals",
    LoadingSubtitle = "Code By Rinn Ui by Sirius Ui remake by Hosvile",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "RinnsHubConfigs",
        FileName = "RinnsHubRivals"
    },
    Discord = {
        Enabled = true,
        Invite = "pzZTWgkUgE",
        RememberJoins = false
    },
    KeySystem = false,
    KeySettings = {
        Title = "ArrayField",
        Subtitle = "Key System",
        Note = "Join the discord (discord.gg/sirius)",
        FileName = "ArrayFieldsKeys",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {"Hello", "Bye"},
        Actions = {
            [1] = {
                Text = 'Click here to copy the key link',
                OnPress = function() end,
            }
        },
    }
})

local Tab = Window:CreateTab("Main Tab", 4483362458)

-- Aimbot settings
local aimbotEnabled = false
local wallCheckEnabled = false
local aimbotFov = 175
local fovTransparency = 0.4
local lockOnRange = 3000
local fovCircle = nil
local aimPart = "Head"
local fovFollowMouse = false
local players = game:GetService("Players")
local camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local wishlistedUsers = {}
local wishlistFriends = false
local fovCircleColor = Color3.new(1, 1, 1)

local function createFovCircle()
    if fovCircle then fovCircle:Remove() end
    fovCircle = Drawing.new("Circle")
    fovCircle.Thickness = 2
    fovCircle.NumSides = 64
    fovCircle.Radius = aimbotFov
    fovCircle.Color = fovCircleColor
    fovCircle.Transparency = fovTransparency
    fovCircle.Visible = aimbotEnabled
end

local function updateFovCircle()
    if fovCircle then
        fovCircle.Position = fovFollowMouse and UserInputService:GetMouseLocation() or Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
        fovCircle.Radius = aimbotFov
        fovCircle.Color = fovCircleColor
        fovCircle.Transparency = fovTransparency
        fovCircle.Visible = aimbotEnabled
    end
end

local function isPlayerVisible(target)
    local origin = camera.CFrame.Position
    local _, onScreen = camera:WorldToScreenPoint(target.Position)
    if not onScreen then
        return false
    end

    local ray = Ray.new(origin, (target.Position - origin).unit * lockOnRange)
    local part, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, {camera, players.LocalPlayer.Character})
    if part and part:IsDescendantOf(target.Parent) then
        return true
    end

    return false
end

local function isUserWishlisted(username)
    for _, user in pairs(wishlistedUsers) do
        if string.find(string.lower(username), string.lower(user)) then
            return true
        end
    end
    return false
end

local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(players:GetPlayers()) do
        if player ~= players.LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            local humanoid = player.Character.Humanoid

            if humanoid.Health > 0 then
                local screenPoint = camera:WorldToScreenPoint(hrp.Position)
                local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - (fovFollowMouse and UserInputService:GetMouseLocation() or Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2))).Magnitude

                if distanceFromCenter <= aimbotFov and (not wallCheckEnabled or isPlayerVisible(hrp)) then
                    local distance = (hrp.Position - players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimAtClosestPlayer()
    if aimbotEnabled then
        local closestPlayer = getClosestPlayer()
        if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild(aimPart) then
            local target = closestPlayer.Character[aimPart]
            camera.CFrame = CFrame.new(camera.CFrame.Position, target.Position)
        end
    end
end

RunService.RenderStepped:Connect(function()
    updateFovCircle()
    aimAtClosestPlayer()
end)

-- Aimbot UI
Tab:CreateToggle({
    Name = "Aimbot",
    Info = {
        Title = 'Enable or Disable Aimbot',
        Description = 'Dont feel like typing all that but remember Dont hold fire spam the fire button',
    },
    CurrentValue = aimbotEnabled,
    Flag = "AimbotToggle",
    Callback = function(Value)
        aimbotEnabled = Value
        updateFovCircle()
    end,
})

Tab:CreateToggle({
    Name = "Aimbot Wall Check",
    Info = {
        Title = 'Enable or Disable Wall Check',
        Description = 'Checks If the person the aimbot is trying to lock on is behind a way and wont lock on to them',
    },
    CurrentValue = wallCheckEnabled,
    Flag = "WallCheckToggle",
    Callback = function(Value)
        wallCheckEnabled = Value
    end,
})

Tab:CreateToggle({
    Name = "Aimbot Fov Follow Mouse",
    Info = {
        Title = 'Enable or Disable Aimbot Fov Follow Mouse',
        Description = 'Makes It so the Aimbot Fov follows your Mouse Dont Use This For Mobile',
    },
    CurrentValue = fovFollowMouse,
    Flag = "FovFollowMouseToggle",
    Callback = function(Value)
        fovFollowMouse = Value
        updateFovCircle()
    end,
})

Tab:CreateSlider({
    Name = "Aimbot Fov Size",
    Info = {
        Title = 'Change The Aimbot Fov Size',
        Description = 'Lets you change the size of the aimbot Fov',
    },
    Range = {1, 1000},
    Increment = 1,
    Suffix = "Studs",
    CurrentValue = aimbotFov,
    Flag = "AimbotFovSlider",
    Callback = function(Value)
        aimbotFov = Value
        updateFovCircle()
    end,
})

Tab:CreateSlider({
    Name = "Aimbot Fov Transparency",
    Info = {
        Title = 'Change The Aimbot Fov Transparency',
        Description = 'Lets you change the transparency of the aimbot Fov',
    },
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = fovTransparency,
    Flag = "AimbotFovTransparencySlider",
    Callback = function(Value)
        fovTransparency = Value
        updateFovCircle()
    end,
})

Tab:CreateDropdown({
    Name = "Aimbot Aim Part",
    Info = {
        Title = 'Change The Aimbot Aim Part',
        Description = 'Lets you change the part of the target the aimbot aims at',
    },
    Options = {"Head", "Torso", "HumanoidRootPart"},
    CurrentOption = aimPart,
    Flag = "AimbotAimPartDropdown",
    Callback = function(Value)
        aimPart = Value
    end,
})

Tab:CreateSlider({
    Name = "Aimbot Lock On Range",
    Info = {
        Title = 'Change The Aimbot Lock On Range',
        Description = 'Lets you change the range at which the aimbot locks on to targets',
    },
    Range = {100, 10000},
    Increment = 100,
    Suffix = "Studs",
    CurrentValue = lockOnRange,
    Flag = "AimbotLockOnRangeSlider",
    Callback = function(Value)
        lockOnRange = Value
    end,
})

-- Initialize FOV circle
createFovCircle()


Tab:CreateSpacing(nil,10)

Tab:CreateColorPicker({
    Name = "Aimbot Fov Color",
    Color = Color3.fromRGB(2,255,255),
    Info = {
        Title = 'Change The Aimbot Fov Color',
        Description = 'Adjusts the color of the Aimbot Fov circle.',
    },
    Default = fovCircleColor,
    Flag = "FovCircleColorPicker",
    Callback = function(Value)
        fovCircleColor = Value
        updateFovCircle()
    end,
})

Tab:CreateToggle({
    Name = "Wishlist Friends Only",
    Info = {
        Title = 'Wishlist Friends Only',
        Description = 'Toggle to only wishlist friends.',
    },
    CurrentValue = wishlistFriends,
    Flag = "WishlistFriendsToggle",
    Callback = function(Value)
        wishlistFriends = Value
        if wishlistFriends then
            local success, result = pcall(function()
                return players:GetFriendsAsync(players.LocalPlayer.UserId)
            end)
            if success then
                wishlistedUsers = {}
                for _, friend in pairs(result) do
                    table.insert(wishlistedUsers, friend.Username)
                end
            else
                print("Error fetching friends:", result)
            end
        end
    end,
})

Tab:CreateButton({
    Name = "Clear Wishlist",
    Info = {
        Title = 'Clear Wishlist',
        Description = 'Clears all users from the wishlist.',
    },
    Callback = function()
        wishlistedUsers = {}
    end,
})

-- Function to find the closest match for a username
local function findClosestUsername(input)
    local closestUsername = nil
    local closestDistance = math.huge

    for _, player in pairs(players:GetPlayers()) do
        local lowerInput = string.lower(input)
        local lowerName = string.lower(player.Name)
        local _, matches = string.gsub(lowerName, lowerInput, "")
        local distance = #lowerInput + #lowerName - 2 * matches
        if matches > 0 and distance < closestDistance then
            closestDistance = distance
            closestUsername = player.Name
        end
    end

    return closestUsername
end

-- Update wishlist to store closest matching usernames
Tab:CreateInput({
    Name = "Wishlist Users On Skibidi",
    PlaceholderText = "The Aimbot wont lock on wishlistedUsers put a comma to show different users",
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        wishlistedUsers = {}
        local userInput = string.split(Text, ",")
        for _, user in pairs(userInput) do
            user = user:match("^%s*(.-)%s*$") -- trim whitespace
            if user ~= "" then
                local closestMatch = findClosestUsername(user)
                if closestMatch then
                    table.insert(wishlistedUsers, closestMatch)
                end
            end
        end
    end,
})

Tab:CreateSpacing(nil, 10)

local toggleState = false
local selectedOption
local randomExecutor

-- Define the map actions
local mapActions = {
    ["Onyx"] = function()
        local args = { [1] = "Onyx" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
    end,
    ["Construction"] = function()
        local args = { [1] = "Construction" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
    end,
    ["Shooting Range"] = function()
        local args = { [1] = "Shooting Range" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
    end,
    ["Docks"] = function()
        local args = { [1] = "Docks" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
    end,
    ["Crossroads"] = function()
        local args = { [1] = "Crossroads" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
    end,
    ["Station"] = function()
        local args = { [1] = "Station" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
    end,
    ["Big Crossroads"] = function()
        local args = { [1] = "Big Crossroads" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
    end,
    ["Backrooms"] = function()
        local args = { [1] = "Backrooms" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
    end,
    ["Arena"] = function()
        local args = { [1] = "Arena" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
    end,
}

Tab:CreateToggle({
    Name = "Auto Vote Map",
    Info = {
        Title = 'Auto Vote Map',
        Image = '12735851647',
        Description = 'Automatically votes the selected map for you Default is Arena,
    },
    CurrentValue = false,
    Flag = "AutoVote", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        toggleState = Value
        if toggleState then
            randomExecutor = game:GetService("RunService").Heartbeat:Connect(function()
                if selectedOption and mapActions[selectedOption] then
                    mapActions[selectedOption]()
                end
            end)
        else
            if randomExecutor then
                randomExecutor:Disconnect()
            end
        end
    end,
})

Tab:CreateSpacing(nil, 10)

Tab:CreateDropdown({
    Name = "Map Option",
    Options = {"Onyx", "Construction", 'Shooting Range', 'Docks', 'Crossroads', 'Station', 'Big Crossroads', 'Backrooms', 'Arena'},
    CurrentOption = "Arena",
    MultiSelection = false,
    Flag = "Dropdown2",
    Callback = function(Option)
        selectedOption = Option
        print(Option)
    end,
})

local VisualsTab = Window:CreateTab("Visuals Tab", 4483362458) -- Title, Image

local highlightColor = Color3.fromRGB(2, 255, 255)
local healthBarFillColor = Color3.fromRGB(0, 255, 0)  -- Initially set to green
local healthBarOutlineColor = Color3.fromRGB(0, 0, 0)
local highlightEnabled = false
local healthBarEnabled = false

local function updatePlayerHighlights(player, enabled, color)
    local character = player.Character or player.CharacterAdded:Wait()
    local highlight = character:FindFirstChildOfClass("Highlight")
    if enabled then
        if not highlight then
            highlight = Instance.new("Highlight")
            highlight.Parent = character
        end
        highlight.FillColor = color
    else
        if highlight then
            highlight:Destroy()
        end
    end
end

local function createHealthBar(player)
    local character = player.Character or player.CharacterAdded:Wait()
    if not character then return end
    
    local healthBarFrame = Instance.new("BillboardGui")
    healthBarFrame.Name = "HealthBar"
    healthBarFrame.Adornee = character:FindFirstChild("HumanoidRootPart")
    healthBarFrame.Size = UDim2.new(0.2, 0, 5, 0)
    healthBarFrame.StudsOffset = Vector3.new(-2, 0, 0)
    healthBarFrame.AlwaysOnTop = true

    local backgroundBar = Instance.new("Frame", healthBarFrame)
    backgroundBar.Size = UDim2.new(1, 0, 1, 0)
    backgroundBar.BackgroundColor3 = healthBarOutlineColor
    backgroundBar.BorderSizePixel = 0

    local healthBar = Instance.new("Frame", backgroundBar)
    healthBar.Name = "Health"
    healthBar.Size = UDim2.new(1, -2, 1, -2)
    healthBar.Position = UDim2.new(0, 1, 0, 1)
    healthBar.BackgroundColor3 = healthBarFillColor
    healthBar.BorderSizePixel = 0

    healthBarFrame.Parent = character
end

local function removeHealthBar(player)
    local character = player.Character or player.CharacterAdded:Wait()
    local healthBarFrame = character:FindFirstChild("HealthBar")
    if healthBarFrame then
        healthBarFrame:Destroy()
    end
end

local function updateHealthBars()
    for _, player in ipairs(game.Players:GetPlayers()) do
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local healthBarFrame = character:FindFirstChild("HealthBar")
                if healthBarFrame then
                    local healthBar = healthBarFrame:FindFirstChild("Health")
                    if healthBar then
                        healthBar.Size = UDim2.new(1, -2, humanoid.Health / humanoid.MaxHealth, -2)
                    end
                end
            end
        end
    end
end

local function onPlayerAdded(player)
    player.CharacterAdded:Connect(function()
        if highlightEnabled then
            updatePlayerHighlights(player, highlightEnabled, highlightColor)
        end
        if healthBarEnabled then
            createHealthBar(player)
        end
    end)
end

local function onPlayerRemoving(player)
    updatePlayerHighlights(player, false)
    removeHealthBar(player)
end

for _, player in ipairs(game.Players:GetPlayers()) do
    onPlayerAdded(player)
end

game.Players.PlayerAdded:Connect(onPlayerAdded)
game.Players.PlayerRemoving:Connect(onPlayerRemoving)
game:GetService("RunService").RenderStepped:Connect(updateHealthBars)

VisualsTab:CreateToggle({
    Name = "Hightlights Esp",
    Info = {
        Title = 'Enable Or Disable Hightlights',
        Image = '12735851647',
        Description = 'Hightlights Every Player',
    },
    CurrentValue = false,
    Flag = "HighlightsEsp",
    Callback = function(Value)
        highlightEnabled = Value
        for _, player in ipairs(game.Players:GetPlayers()) do
            updatePlayerHighlights(player, highlightEnabled, highlightColor)
        end
    end,
})

VisualsTab:CreateSpacing(nil, 10)

VisualsTab:CreateColorPicker({
    Name = "Hightlights Esp Color Changer",
    Color = highlightColor,
    Flag = "HighlightsEspColorPicker",
    Callback = function(Value)
        highlightColor = Value
        if highlightEnabled then
            for _, player in ipairs(game.Players:GetPlayers()) do
                updatePlayerHighlights(player, highlightEnabled, highlightColor)
            end
        end
    end
})

VisualsTab:CreateToggle({
    Name = "Health Bar Esp",
    Info = {
        Title = 'Enable Or Disable Health Bar ESP',
        Image = '12735851647',
        Description = 'Displays Health Bars for Every Player',
    },
    CurrentValue = false,
    Flag = "Toggle2",
    Callback = function(Value)
        healthBarEnabled = Value
        for _, player in ipairs(game.Players:GetPlayers()) do
            if healthBarEnabled then
                createHealthBar(player)
            else
                removeHealthBar(player)
            end
        end
    end,
})

VisualsTab:CreateSpacing(nil, 10)

VisualsTab:CreateColorPicker({
    Name = "Health Bar Outline Color",
    Color = healthBarOutlineColor,
    Flag = "HealthBarOutlineColorPicker",
    Callback = function(Value)
        healthBarOutlineColor = Value
        if healthBarEnabled then
            for _, player in ipairs(game.Players:GetPlayers()) do
                local character = player.Character
                if character then
                    local healthBarFrame = character:FindFirstChild("HealthBar")
                    if healthBarFrame then
                        local backgroundBar = healthBarFrame:FindFirstChildOfClass("Frame")
                        if backgroundBar then
                            backgroundBar.BackgroundColor3 = healthBarOutlineColor
                        end
                    end
                end
            end
        end
    end
})

VisualsTab:CreateColorPicker({
    Name = "Health Bar Fill Color",
    Color = healthBarFillColor,
    Flag = "HealthBarFillColorPicker",
    Callback = function(Value)
        healthBarFillColor = Value
        if healthBarEnabled then
            for _, player in ipairs(game.Players:GetPlayers()) do
                local character = player.Character
                if character then
                    local healthBarFrame = character:FindFirstChild("HealthBar")
                    if healthBarFrame then
                        local backgroundBar = healthBarFrame:FindFirstChildOfClass("Frame")
                        if backgroundBar then
                            local healthBar = backgroundBar:FindFirstChild("Health")
                            if healthBar then
                                healthBar.BackgroundColor3 = healthBarFillColor
                            end
                        end
                    end
                end
            end
        end
    end
})

