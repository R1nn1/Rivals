local ArrayField = loadstring(game:HttpGet("https://raw.githubusercontent.com/Hosvile/Refinement/main/MC%3AArrayfield%20Library"))()

if not ArrayField then
    error("Failed to load ArrayField library")
end

local Window = ArrayField:CreateWindow({
    Name = "Rinns Hub Rivals",
    LoadingTitle = "Rinns Hub Rivals",
    LoadingSubtitle = "Code By Rinn Ui by Sirius Ui remake by Hosvile",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "RinnsHubConfigs",
        FileName = "RinnsHubRivals"
    },
    Discord = {
        Enabled = true,
        Invite = "pzZTWgkUgE",
        RememberJoins = false
    },
    KeySystem = false,
    KeySettings = {
        Title = "ArrayField",
        Subtitle = "Key System",
        Note = "Join the discord (discord.gg/sirius)",
        FileName = "ArrayFieldsKeys",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {"Hello", "Bye"},
        Actions = {
            [1] = {
                Text = 'Click here to copy the key link',
                OnPress = function() end,
            }
        },
    }
})

local Tab = Window:CreateTab("Main Tab", 4483362458)

local Label = Tab:CreateLabel("Click The Button On The Top Left To Open Tabs https://discord.com/invite/8HKD7DnKh4",Section)

-- Aimbot settings
local aimbotEnabled = false
local wallCheckEnabled = false
local aimbotFov = 175
local fovTransparency = 0.4
local fovThickness = 2
local lockOnRange = 3000
local fovCircle = nil
local aimPart = "Head"
local fovFollowMouse = false
local players = game:GetService("Players")
local camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local wishlistedUsers = {}
local wishlistFriends = false
local fovCircleColor = Color3.new(1, 1, 1)

local function createFovCircle()
    if fovCircle then fovCircle:Remove() end
    fovCircle = Drawing.new("Circle")
    fovCircle.Thickness = fovThickness
    fovCircle.NumSides = 64
    fovCircle.Radius = aimbotFov
    fovCircle.Color = fovCircleColor
    fovCircle.Transparency = fovTransparency
    fovCircle.Visible = aimbotEnabled
end

local function updateFovCircle()
    if fovCircle then
        fovCircle.Position = fovFollowMouse and UserInputService:GetMouseLocation() or Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
        fovCircle.Radius = aimbotFov
        fovCircle.Color = fovCircleColor
        fovCircle.Transparency = fovTransparency
        fovCircle.Thickness = fovThickness
        fovCircle.Visible = aimbotEnabled
    end
end

local function isPlayerVisible(target)
    local origin = camera.CFrame.Position
    local _, onScreen = camera:WorldToScreenPoint(target.Position)
    if not onScreen then
        return false
    end

    local ray = Ray.new(origin, (target.Position - origin).unit * lockOnRange)
    local part, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, {camera, players.LocalPlayer.Character})
    if part and part:IsDescendantOf(target.Parent) then
        return true
    end

    return false
end

local function isUserWishlisted(username)
    for _, user in pairs(wishlistedUsers) do
        if string.find(string.lower(username), string.lower(user)) then
            return true
        end
    end
    return false
end

local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(players:GetPlayers()) do
        if player ~= players.LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            local humanoid = player.Character.Humanoid

            if humanoid.Health > 0 and not isUserWishlisted(player.Name) then
                local screenPoint = camera:WorldToScreenPoint(hrp.Position)
                local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - (fovFollowMouse and UserInputService:GetMouseLocation() or Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2))).Magnitude

                if distanceFromCenter <= aimbotFov and (not wallCheckEnabled or isPlayerVisible(hrp)) then
                    local distance = (hrp.Position - players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimAtClosestPlayer()
    if aimbotEnabled then
        local closestPlayer = getClosestPlayer()
        if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild(aimPart) then
            local target = closestPlayer.Character[aimPart]
            local targetPosition = target.Position
            local currentCameraPosition = camera.CFrame.Position
            local direction = (targetPosition - currentCameraPosition).unit
            local targetCameraCFrame = CFrame.new(currentCameraPosition, currentCameraPosition + direction)
            camera.CFrame = targetCameraCFrame
        end
    end
end

RunService.RenderStepped:Connect(function()
    updateFovCircle()
    aimAtClosestPlayer()
end)

--// No Flash Function
local function noFlash()
    if game:GetService("Players").LocalPlayer.PlayerScripts.Assets.Misc:FindFirstChild("FlashbangEffect") then 
        game:GetService("Players").LocalPlayer.PlayerScripts.Assets.Misc.FlashbangEffect:Destroy()
    end
end

--// No Smoke Function
local function noSmoke()
    if game:GetService("Players").LocalPlayer.PlayerScripts.Assets.Misc:FindFirstChild("SmokeClouds") then 
        game:GetService("Players").LocalPlayer.PlayerScripts.Assets.Misc.SmokeClouds:Destroy()
    end
end

Tab:CreateButton({
    Name = "No Flash",
    Info = {
        Title = 'No Flash',
        Description = 'Makes You not be able to get flashed by the flashbang',
    },
    Interact = 'Changable',
    Callback = function()
        noFlash()
    end,
})

Tab:CreateButton({
    Name = "No Smoke",
    Info = {
        Title = 'No Smoke',
        Description = 'Lets You Be Able To See even tho yourcin smoke',
    },
    Interact = 'Changable',
    Callback = function()
        noSmoke()
    end,
})

-- Aimbot UI
Tab:CreateToggle({
    Name = "Aimbot",
    Info = {
        Title = 'Enable or Disable Aimbot',
        Description = 'Dont feel like typing all that but remember Dont hold fire spam the fire button',
    },
    CurrentValue = aimbotEnabled,
    Flag = "AimbotToggle",
    Callback = function(Value)
        aimbotEnabled = Value
        updateFovCircle()
    end,
})

Tab:CreateToggle({
    Name = "Aimbot Wall Check",
    Info = {
        Title = 'Enable or Disable Wall Check',
        Description = 'Checks If the person the aimbot is trying to lock on is behind a way and wont lock on to them',
    },
    CurrentValue = wallCheckEnabled,
    Flag = "WallCheckToggle",
    Callback = function(Value)
        wallCheckEnabled = Value
    end,
})

Tab:CreateToggle({
    Name = "Aimbot Fov Follow Mouse",
    Info = {
        Title = 'Enable or Disable Aimbot Fov Follow Mouse',
        Description = 'Makes It so the Aimbot Fov follows your Mouse Dont Use This For Mobile',
    },
    CurrentValue = fovFollowMouse,
    Flag = "FovFollowMouseToggle",
    Callback = function(Value)
        fovFollowMouse = Value
        updateFovCircle()
    end,
})

Tab:CreateSpacing(nil,5)

Tab:CreateSlider({
    Name = "Aimbot Fov Size",
    Info = {
        Title = 'Change The Aimbot Fov Size',
        Description = 'Lets you change the size of the aimbot Fov',
    },
    Range = {1, 1000},
    Increment = 1,
    Suffix = "Studs",
    CurrentValue = aimbotFov,
    Flag = "AimbotFovSlider",
    Callback = function(Value)
        aimbotFov = Value
        updateFovCircle()
    end,
})

Tab:CreateSlider({
    Name = "Aimbot Fov Transparency",
    Info = {
        Title = 'Change The Aimbot Fov Transparency',
        Description = 'Lets you change the transparency of the aimbot Fov',
    },
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = fovTransparency,
    Flag = "AimbotFovTransparencySlider",
    Callback = function(Value)
        fovTransparency = Value
        updateFovCircle()
    end,
})

print("testing1")
Tab:CreateSlider({
    Name = "Aimbot Fov Thickness",
    Info = {
        Title = 'Change The Aimbot Fov Thickness',
        Description = 'Lets you change the thickness of the aimbot Fov',
    },
    Range = {1, 10},
    Increment = 0.01,
    Suffix = "",
    CurrentValue = fovThickness,
    Flag = "AimbotFovThicknessSlider",
    Callback = function(Value)
        fovThickness = Value
        updateFovCircle()
    end,
})

print("testing2")

Tab:CreateDropdown({
    Name = "Aimbot Aim Part",
    Info = {
        Title = 'Change The Aimbot Aim Part',
        Description = 'Lets you change the part of the target the aimbot aims at',
    },
    Options = {"Head", "Torso", "HumanoidRootPart"},
    CurrentOption = aimPart,
    Flag = "AimbotAimPartDropdown",
    Callback = function(Value)
        aimPart = Value
    end,
})

Tab:CreateSlider({
    Name = "Aimbot Lock On Range",
    Info = {
        Title = 'Change The Aimbot Lock On Range',
        Description = 'Lets you change the range at which the aimbot locks on to targets',
    },
    Range = {100, 10000},
    Increment = 1,
    Suffix = "Studs",
    CurrentValue = lockOnRange,
    Flag = "AimbotLockOnRangeSlider",
    Callback = function(Value)
        lockOnRange = Value
    end,
})

print("testing 3")

Tab:CreateKeybind({
    Name = "Aimbot Toggle Keybind",
    CurrentKeybind = "Q",
    HoldToInteract = false,
    Flag = "AimbotKeybind",
    Callback = function(Keybind)
        aimbotEnabled = not aimbotEnabled
        updateFovCircle()
    end,
})

-- Initialize FOV circle
createFovCircle()
print("testing4")

Tab:CreateSpacing(nil,10)

Tab:CreateToggle({
    Name = "Wishlist Friends",
    Info = {
        Title = 'Wishlist Friends',
        Description = 'Toggle this on to wishlist friends.',
    },
    CurrentValue = wishlistFriends,
    Flag = "WishlistFriendsToggle",
    Callback = function(Value)
        wishlistFriends = Value
        if wishlistFriends then
            wishlistedUsers = {}
            local success, result = pcall(function()
                return players:GetFriendsAsync(players.LocalPlayer.UserId)
            end)
            if success then
                for _, friend in pairs(result) do
                    for _, player in pairs(players:GetPlayers()) do
                        if player.Name == friend.Username then
                            table.insert(wishlistedUsers, friend.Username)
                        end
                    end
                end
            else
                print("Error fetching friends:", result)
            end
        end
    end,
})

Tab:CreateButton({
    Name = "Clear Wishlist",
    Info = {
        Title = 'Clear Wishlist',
        Description = 'Clears all users from the wishlist.',
    },
    Callback = function()
        wishlistedUsers = {}
    end,
})

-- Function to find the closest match for a username
local function findClosestUsername(input)
    local closestUsername = nil
    local closestDistance = math.huge

    for _, player in pairs(players:GetPlayers()) do
        local lowerInput = string.lower(input)
        local lowerName = string.lower(player.Name)
        local _, matches = string.gsub(lowerName, lowerInput, "")
        local distance = #lowerInput + #lowerName - 2 * matches
        if matches > 0 and distance < closestDistance then
            closestDistance = distance
            closestUsername = player.Name
        end
    end

    return closestUsername
end

-- Update wishlist to store closest matching usernames
Tab:CreateInput({
    Name = "Wishlist Users",
    PlaceholderText = "Put UserNames to wishlist Here",
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        wishlistedUsers = {}
        local userInput = string.split(Text, ",")
        for _, user in pairs(userInput) do
            user = user:match("^%s*(.-)%s*$") -- trim whitespace
            if user ~= "" then
                local closestMatch = findClosestUsername(user)
                if closestMatch then
                    table.insert(wishlistedUsers, closestMatch)
                end
            end
        end
    end,
})

Tab:CreateSpacing(nil, 10)

local AutoVoteMap = false
local selectedOption = "Arena"
local randomExecutor

-- Define the map actions
local mapActions = {
    ["Onyx"] = function()
        local args = { [1] = "Onyx" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Onyx")
    end,
    ["Construction"] = function()
        local args = { [1] = "Construction" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Construction")
    end,
    ["Shooting Range"] = function()
        local args = { [1] = "Shooting Range" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Shooting Range")
    end,
    ["Docks"] = function()
        local args = { [1] = "Docks" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Docks")
    end,
    ["Crossroads"] = function()
        local args = { [1] = "Crossroads" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Crossroads")
    end,
    ["Station"] = function()
        local args = { [1] = "Station" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Station")
    end,
    ["Big Crossroads"] = function()
        local args = { [1] = "Big Crossroads" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Big Crossroads")
    end,
    ["Backrooms"] = function()
        local args = { [1] = "Backrooms" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Backrooms")
    end,
    ["Arena"] = function()
        local args = { [1] = "Arena" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Arena")
    end,
}

-- Create the toggle for Auto Vote Map
Tab:CreateToggle({
    Name = "Auto Vote Map",
    Info = {
        Title = 'Auto Vote Map',
        Image = '12735851647',
        Description = 'Automatically votes the selected map in the dropdown below for you',
    },
    CurrentValue = false,
    Flag = "AutoVote", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        AutoVoteMap = Value
        if AutoVoteMap then
            print("Auto Vote Map enabled")
        else
            print("Auto Vote Map disabled")
        end
    end,
})

-- Create the dropdown for map selection
Tab:CreateDropdown({
    Name = "Map Selector",
    Options = {"Onyx", "Construction", "Shooting Range", "Docks", "Crossroads", "Station", "Big Crossroads", "Backrooms", "Arena"},
    CurrentOption = "Arena",
    MultiSelection = false,
    Flag = "MapDropDown",
    Callback = function(Option)
        selectedOption = Option
        print("Selected map: " .. Option)
    end,
})

local EspTab = Window:CreateTab("Esp Tab", 4483362458)

local boxes = {}
local names = {}
local distances = {}
local healthBars = {}
local healthTexts = {}
local connections = {}

local function createBox(player)
    if player == game:GetService("Players").LocalPlayer then return end

    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Transparency = 1
    box.Color = Color3.new(1, 1, 1)
    box.Filled = false
    box.Outline = true
    box.OutlineColor = Color3.new(0, 0, 0)
    boxes[player] = box

    if nameEspEnabled then
        local name = Drawing.new("Text")
        name.Size = 10
        name.Color = Color3.new(1, 1, 1)
        name.Center = true
        name.Outline = true
        name.OutlineColor = Color3.new(0, 0, 0)
        name.Text = player.Name
        names[player] = name
    end

    if distanceEspEnabled then
        local distance = Drawing.new("Text")
        distance.Size = 10
        distance.Color = Color3.new(1, 1, 1)
        distance.Center = true
        distance.Outline = true
        distance.OutlineColor = Color3.new(0, 0, 0)
        distances[player] = distance
    end

    if healthBarEspEnabled then
        local healthBar = Drawing.new("Square")
        healthBar.Thickness = 1
        healthBar.Transparency = 1
        healthBar.Color = Color3.new(0, 0, 0)
        healthBar.Filled = false

        local healthBarGreen = Drawing.new("Square")
        healthBarGreen.Thickness = 0
        healthBarGreen.Transparency = 1
        healthBarGreen.Color = Color3.new(0, 1, 0)
        healthBarGreen.Filled = true

        local healthBarRed = Drawing.new("Square")
        healthBarRed.Thickness = 0
        healthBarRed.Transparency = 1
        healthBarRed.Color = Color3.new(1, 0, 0)
        healthBarRed.Filled = true

        healthBars[player] = {healthBar, healthBarGreen, healthBarRed}
    end

    if healthTextEspEnabled then
        local healthText = Drawing.new("Text")
        healthText.Size = 10
        healthText.Color = Color3.new(1, 1, 1)
        healthText.Center = true
        healthText.Outline = true
        healthText.OutlineColor = Color3.new(0, 0, 0)
        healthTexts[player] = healthText
    end
end

local function removeBox(player)
    if boxes[player] then
        boxes[player]:Remove()
        boxes[player] = nil
    end
    if names[player] then
        names[player]:Remove()
        names[player] = nil
    end
    if distances[player] then
        distances[player]:Remove()
        distances[player] = nil
    end
    if healthBars[player] then
        healthBars[player][1]:Remove()
        healthBars[player][2]:Remove()
        healthBars[player][3]:Remove()
        healthBars[player] = nil
    end
    if healthTexts[player] then
        healthTexts[player]:Remove()
        healthTexts[player] = nil
    end
end

local function updateBoxes()
    for player, box in pairs(boxes) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            local vector, onScreen = game.Workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                box.Visible = true
                local scaleFactor = 0.5 / (vector.Z / 100)
                box.Size = Vector2.new(20 * scaleFactor, 35 * scaleFactor)
                box.Position = Vector2.new(vector.X - 10 * scaleFactor, vector.Y - 17.5 * scaleFactor)

                if names[player] then
                    names[player].Visible = true
                    names[player].Position = Vector2.new(vector.X, vector.Y - 20 * scaleFactor)
                end

                if distances[player] then
                    distances[player].Visible = true
                    local distance = (game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                    distances[player].Text = string.format("%.0f studs", distance)
                    distances[player].Position = Vector2.new(vector.X, vector.Y + 20 * scaleFactor)
                end

                if healthBars[player] then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        local health = humanoid.Health
                        local maxHealth = humanoid.MaxHealth
                        local healthPercent = health / maxHealth

                        local healthBar = healthBars[player][1]
                        local healthBarGreen = healthBars[player][2]
                        local healthBarRed = healthBars[player][3]

                        healthBar.Visible = true
                        healthBarGreen.Visible = true
                        healthBarRed.Visible = true

                        healthBar.Size = Vector2.new(3 * scaleFactor, 35 * scaleFactor)
                        healthBar.Position = Vector2.new(vector.X - 13 * scaleFactor, vector.Y - 17.5 * scaleFactor)

                        healthBarGreen.Size = Vector2.new(3 * scaleFactor, 35 * scaleFactor * healthPercent)
                        healthBarGreen.Position = Vector2.new(vector.X - 13 * scaleFactor, vector.Y - 17.5 * scaleFactor + (35 * scaleFactor * (1 - healthPercent)))

                        healthBarRed.Size = Vector2.new(3 * scaleFactor, 35 * scaleFactor * (1 - healthPercent))
                        healthBarRed.Position = Vector2.new(vector.X - 13 * scaleFactor, vector.Y - 17.5 * scaleFactor)
                    else
                        healthBars[player][1].Visible = false
                        healthBars[player][2].Visible = false
                        healthBars[player][3].Visible = false
                    end
                end

                if healthTexts[player] then
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        local health = humanoid.Health
                        local maxHealth = humanoid.MaxHealth

                        healthTexts[player].Visible = true
                        healthTexts[player].Text = string.format("%.0f / %.0f", health, maxHealth)
                        healthTexts[player].Position = Vector2.new(vector.X + 15 * scaleFactor, vector.Y)
                    else
                        healthTexts[player].Visible = false
                    end
                end
            else
                box.Visible = false
                if names[player] then
                    names[player].Visible = false
                end
                if distances[player] then
                    distances[player].Visible = false
                end
                if healthBars[player] then
                    healthBars[player][1].Visible = false
                    healthBars[player][2].Visible = false
                    healthBars[player][3].Visible = false
                end
                if healthTexts[player] then
                    healthTexts[player].Visible = false
                end
            end
        else
            box.Visible = false
            if names[player] then
                names[player].Visible = false
            end
            if distances[player] then
                distances[player].Visible = false
            end
            if healthBars[player] then
                healthBars[player][1].Visible = false
                healthBars[player][2].Visible = false
                healthBars[player][3].Visible = false
            end
            if healthTexts[player] then
                healthTexts[player].Visible = false
            end
        end
    end
end

local function playerAdded(player)
    player.CharacterAdded:Connect(function()
        createBox(player)
    end)

    player.CharacterRemoving:Connect(function()
        removeBox(player)
    end)

    -- Create ESP for the character if it exists
    if player.Character then
        createBox(player)
    end
end

local function toggleBoxESP(enabled)
    if enabled then
        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            playerAdded(player)
        end
        connections.renderStepped = game:GetService("RunService").RenderStepped:Connect(updateBoxes)
    else
        for _, player in pairs(game:GetService("Players"):GetPlayers()) do
            removeBox(player)
        end
        if connections.renderStepped then
            connections.renderStepped:Disconnect()
            connections.renderStepped = nil
        end
    end
end

local function toggleNameESP(enabled)
    nameEspEnabled = enabled
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if enabled then
            if not names[player] then
                local name = Drawing.new("Text")
                name.Size = 10
                name.Color = Color3.new(1, 1, 1)
                name.Center = true
                name.Outline = true
                name.OutlineColor = Color3.new(0, 0, 0)
                name.Text = player.Name
                names[player] = name
            end
        else
            if names[player] then
                names[player]:Remove()
                names[player] = nil
            end
        end
    end
end

local function toggleDistanceESP(enabled)
    distanceEspEnabled = enabled
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if enabled then
            if not distances[player] then
                local distance = Drawing.new("Text")
                distance.Size = 10
                distance.Color = Color3.new(1, 1, 1)
                distance.Center = true
                distance.Outline = true
                distance.OutlineColor = Color3.new(0, 0, 0)
                distances[player] = distance
            end
        else
            if distances[player] then
                distances[player]:Remove()
                distances[player] = nil
            end
        end
    end
end

local function toggleHealthBarESP(enabled)
    healthBarEspEnabled = enabled
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if enabled then
            if not healthBars[player] then
                local healthBar = Drawing.new("Square")
                healthBar.Thickness = 1
                healthBar.Transparency = 1
                healthBar.Color = Color3.new(0, 0, 0)
                healthBar.Filled = false

                local healthBarGreen = Drawing.new("Square")
                healthBarGreen.Thickness = 0
                healthBarGreen.Transparency = 1
                healthBarGreen.Color = Color3.new(0, 1, 0)
                healthBarGreen.Filled = true

                local healthBarRed = Drawing.new("Square")
                healthBarRed.Thickness = 0
                healthBarRed.Transparency = 1
                healthBarRed.Color = Color3.new(1, 0, 0)
                healthBarRed.Filled = true

                healthBars[player] = {healthBar, healthBarGreen, healthBarRed}
            end
        else
            if healthBars[player] then
                healthBars[player][1]:Remove()
                healthBars[player][2]:Remove()
                healthBars[player][3]:Remove()
                healthBars[player] = nil
            end
        end
    end
end

local function toggleHealthTextESP(enabled)
    healthTextEspEnabled = enabled
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if enabled then
            if not healthTexts[player] then
                local healthText = Drawing.new("Text")
                healthText.Size = 10
                healthText.Color = Color3.new(1, 1, 1)
                healthText.Center = true
                healthText.Outline = true
                healthText.OutlineColor = Color3.new(0, 0, 0)
                healthTexts[player] = healthText
            end
        else
            if healthTexts[player] then
                healthTexts[player]:Remove()
                healthTexts[player] = nil
            end
        end
    end
end

game:GetService("Players").PlayerAdded:Connect(playerAdded)
game:GetService("Players").PlayerRemoving:Connect(removeBox)

EspTab:CreateToggle({
    Name = "Box Esp",
    Default = false,
    Callback = function(value)
        toggleBoxESP(value)
    end
})

EspTab:CreateToggle({
    Name = "Name esp",
    Default = false,
    Callback = function(value)
        toggleNameESP(value)
    end
})

EspTab:CreateToggle({
    Name = "Distance esp",
    Default = false,
    Callback = function(value)
        toggleDistanceESP(value)
    end
})

EspTab:CreateToggle({
    Name = "Health Bar esp",
    Default = false,
    Callback = function(value)
        toggleHealthBarESP(value)
    end
})

EspTab:CreateToggle({
    Name = "Health Text esp",
    Default = false,
    Callback = function(value)
        toggleHealthTextESP(value)
    end
})

local MiscTab = Window:CreateTab("Misc Tab", 4483362458) -- Title, Image

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local function rotateMouse(rotationSpeed)
    local playerName = Players.LocalPlayer.Name
    local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    local mainGui = playerGui:WaitForChild("MainGui")
    local mainFrame = mainGui:WaitForChild("MainFrame")
    local itemInterfaces = mainFrame:WaitForChild("ItemInterfaces")

    for _, item in pairs(itemInterfaces:GetChildren()) do
        if item.Name:find(playerName) then
            local mouse = item:FindFirstChild("Mouse")
            if mouse then
                RunService.RenderStepped:Connect(function()
                    mouse.Rotation = mouse.Rotation + rotationSpeed
                end)
            end
        end
    end
end

local rotationSpeed = 1
local rotationConnection

MiscTab:CreateToggle({
    Name = "Rotating Crosshair",
    Info = {
        Title = 'Makes Your Crosshair Rotate',
        Image = '12735851647',
        Description = 'so cool',
    },
    CurrentValue = false,
    Flag = "CrossHairRotate", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value then
            rotationConnection = RunService.RenderStepped:Connect(function()
                rotateMouse(rotationSpeed)
            end)
        else
            if rotationConnection then
                rotationConnection:Disconnect()
            end
        end
    end,
})

MiscTab:CreateSlider({
    Name = "Rotation Speed",
    Range = {0, 10},
    Increment = 0.1,
    Suffix = "Speed",
    CurrentValue = 1,
    Flag = "RotateSpeed",
    Callback = function(Value)
        rotationSpeed = Value
    end,
})

local PlayerTab = Window:CreateTab("Players Tab", 4483362458) -- Title, Image

PlayerTab:CreateSpacing(nil, 10)

local enableLongJump = false
local enableScytheDash = false
local enableClickTeleport = false

local function createLongJumpButton()
    if game.CoreGui:FindFirstChild("LongJumpGui") then
        return
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "LongJumpGui"
    screenGui.Parent = game.CoreGui

    local longJumpButton = Instance.new("TextButton")
    longJumpButton.Size = UDim2.new(0, 50, 0, 50)
    longJumpButton.Position = UDim2.new(1, -60, 0.5, -25)
    longJumpButton.Text = "Jump"
    longJumpButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    longJumpButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    longJumpButton.BackgroundTransparency = 0.5

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(1, 0)
    uiCorner.Parent = longJumpButton

    longJumpButton.Draggable = true
    longJumpButton.Active = true

    longJumpButton.MouseButton1Click:Connect(function()
        if enableLongJump then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame * CFrame.new(0, 50, 0)}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end)

    longJumpButton.Parent = screenGui
end

local function createScytheDashButton()
    if game.CoreGui:FindFirstChild("ScytheDashGui") then
        return
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ScytheDashGui"
    screenGui.Parent = game.CoreGui

    local scytheDashButton = Instance.new("TextButton")
    scytheDashButton.Size = UDim2.new(0, 50, 0, 50)
    scytheDashButton.Position = UDim2.new(0, 10, 0.5, -25)
    scytheDashButton.Text = "Dash"
    scytheDashButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    scytheDashButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    scytheDashButton.BackgroundTransparency = 0.5

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(1, 0)
    uiCorner.Parent = scytheDashButton

    scytheDashButton.Draggable = true
    scytheDashButton.Active = true

    local function dash()
        if enableScytheDash then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if rootPart and humanoid then
                    local camera = workspace.CurrentCamera
                    local lookVector = camera.CFrame.LookVector
                    local dashDirection = lookVector.Unit * 30 -- Ensure the lookVector is normalized
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame + dashDirection}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end

    scytheDashButton.MouseButton1Click:Connect(dash)

    scytheDashButton.Parent = screenGui
end

local function enableClickTeleportFunction()
    local player = game:GetService("Players").LocalPlayer
    local mouse = player:GetMouse()
    
    mouse.Button1Down:Connect(function()
        if enableClickTeleport then
            local character = player.Character or player.CharacterAdded:Wait()
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                rootPart.CFrame = CFrame.new(mouse.Hit.p + Vector3.new(0, 3, 0))
            end
        end
    end)
end

PlayerTab:CreateToggle({
    Name = "Enable Fake Scythe Dash",
    Info = {
        Title = 'Enable Fake Scythe Dash',
        Image = '12735851647',
        Description = 'Enables the Fake Scythe Dash action',
    },
    CurrentValue = false,
    Flag = "EnableScytheDash", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        enableScytheDash = Value
    end,
})

PlayerTab:CreateToggle({
    Name = "Show Fake Scythe Dash Button",
    Info = {
        Title = 'Show Fake Scythe Dash Button',
        Image = '12735851647',
        Description = 'Shows the Fake Scythe Dash button',
    },
    CurrentValue = false,
    Flag = "ShowScytheDashButton", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value then
            createScytheDashButton()
        else
            local gui = game.CoreGui:FindFirstChild("ScytheDashGui")
            if gui then
                gui:Destroy()
            end
        end
        print(Value)
    end,
})

PlayerTab:CreateKeybind({
    Name = "Fake Scythe Dash Keybind",
    CurrentKeybind = "E",
    HoldToInteract = false,
    Flag = "ScytheDashKeybind",
    Callback = function(Keybind)
        if enableScytheDash then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if rootPart and humanoid then
                    local camera = workspace.CurrentCamera
                    local lookVector = camera.CFrame.LookVector
                    local dashDirection = lookVector.Unit * 30 -- Ensure the lookVector is normalized
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame + dashDirection}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
                    end
    end,
})

PlayerTab:CreateSpacing(nil, 10)

PlayerTab:CreateToggle({
    Name = "Enable Long Jump",
    Info = {
        Title = 'Enable Long Jump',
        Image = '12735851647',
        Description = 'Enables the Long Jump action',
    },
    CurrentValue = false,
    Flag = "EnableLongJump", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        enableLongJump = Value
    end,
})

PlayerTab:CreateToggle({
    Name = "Show Long Jump Button",
    Info = {
        Title = 'Show Long Jump Button',
        Image = '12735851647',
        Description = 'Shows the Long Jump button',
    },
    CurrentValue = false,
    Flag = "ShowLongJumpButton", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value then
            createLongJumpButton()
        else
            local gui = game.CoreGui:FindFirstChild("LongJumpGui")
            if gui then
                gui:Destroy()
            end
        end
        print(Value)
    end,
})

PlayerTab:CreateKeybind({
    Name = "Long Jump Keybind",
    CurrentKeybind = "Q",
    HoldToInteract = false,
    Flag = "LongJumpKeybind",
    Callback = function(Keybind)
        if enableLongJump then
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame * CFrame.new(0, 50, 0)}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end,
})

PlayerTab:CreateToggle({
    Name = "Click Teleport",
    Info = {
        Title = 'Click Teleport',
        Image = '12735851647',
        Description = 'Teleports You Wherever you click',
    },
    CurrentValue = false,
    Flag = "EnableClickTeleport", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        enableClickTeleport = Value
        if enableClickTeleport then
            enableClickTeleportFunction()
        end
    end,
})

function reduceLag()
    -- Lower rendering quality level
    settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    
    -- Terrain settings
    Workspace.Terrain.WaterWaveSize = 0
    Workspace.Terrain.WaterWaveSpeed = 0
    Workspace.Terrain.WaterReflectance = 0
    Workspace.Terrain.WaterTransparency = 0
    
    -- Adjusting properties of parts
    for _, v in pairs(Workspace:GetDescendants()) do
        if v:IsA("Part") or v:IsA("UnionOperation") or v:IsA("MeshPart") or v:IsA("WedgePart") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
            v.Material = Enum.Material.Plastic
            v.Reflectance = 0
            v.CastShadow = false  -- Disable shadows
        elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
            v.Enabled = false  -- Disable particle emitters
        end
    end
    
    -- Lower graphics settings
    game.Lighting.GlobalShadows = false
    game.Lighting.FogEnd = 100000  -- Max fog distance
    
    -- Reduce render distance
    game.Players.LocalPlayer.CameraMaxZoomDistance = 50  -- Example value, adjust as needed
    
    print('Lag')
end

-- Button setup
MiscTab:CreateButton({
    Name = "Reduce Lag",
    Info = {
        Title = 'Less Lag',
        Description = 'reduces lag in the game.',
    },
    Interact = 'Changable',
    Callback = function()
        reduceLag()
    end,
})

ArrayField:Notify({
   Title = "Aimbot Wishlisting",
   Content = "The Aimbot Wont Lock On To Wishlisted Users put a comma to show different users",
   Duration = 9,
   Image = 4483362458,
   Actions = { -- Notification Buttons
      Ignore = {
         Name = "Okay!",
         Callback = function()
         print("The user tapped Okay!")
      end
   },
 },
})

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Create the FPS counter toggle
MiscTab:CreateToggle({
    Name = "Fps Counter",
    Info = {
        Title = 'FPS Counter',
        Image = '12735851647',
        Description = 'Shows A Gui That Will Show Your Fps',
    },
    CurrentValue = false,
    Flag = "FPSCounterToggle",
    Callback = function(Value)
        if Value then
            createFPSCounter()
        else
            removeFPSCounter()
        end
    end,
})

-- Create the ping counter toggle
MiscTab:CreateToggle({
    Name = "Ping Counter",
    Info = {
        Title = 'Ping Counter',
        Image = '12735851647',
        Description = 'Makes A Gui That Will Show Your Ping',
    },
    CurrentValue = false,
    Flag = "PingCounterToggle",
    Callback = function(Value)
        if Value then
            createPingCounter()
        else
            removePingCounter()
        end
    end,
})

-- Function to create FPS counter
function createFPSCounter()
    local screenGui = Instance.new("ScreenGui", game.CoreGui)
    screenGui.Name = "FPSCounter"
    screenGui.ResetOnSpawn = false

    local textLabel = Instance.new("TextLabel", screenGui)
    textLabel.Size = UDim2.new(0, 40, 0, 40)
    textLabel.Position = UDim2.new(0, 10, 0, 10)
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.BackgroundTransparency = 0.5
    textLabel.TextStrokeTransparency = 0
    textLabel.Font = Enum.Font.SourceSans
    textLabel.TextSize = 14
    textLabel.Text = "FPS: 0"
    textLabel.Active = true
    textLabel.Draggable = true

    RunService.RenderStepped:Connect(function(deltaTime)
        textLabel.Text = string.format("FPS: %d", math.floor(1 / deltaTime))
    end)
end

-- Function to remove FPS counter
function removeFPSCounter()
    if game.CoreGui:FindFirstChild("FPSCounter") then
        game.CoreGui.FPSCounter:Destroy()
    end
end

-- Function to create Ping counter
function createPingCounter()
    local screenGui = Instance.new("ScreenGui", game.CoreGui)
    screenGui.Name = "PingCounter"
    screenGui.ResetOnSpawn = false

    local textLabel = Instance.new("TextLabel", screenGui)
    textLabel.Size = UDim2.new(0, 40, 0, 40)
    textLabel.Position = UDim2.new(0, 10, 0, 70)
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.BackgroundTransparency = 0.5
    textLabel.TextStrokeTransparency = 0
    textLabel.Font = Enum.Font.SourceSans
    textLabel.TextSize = 14
    textLabel.Text = "Ping: 0"
    textLabel.Active = true
    textLabel.Draggable = true

    RunService.Heartbeat:Connect(function()
        textLabel.Text = string.format("Ping: %d ms", game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
    end)
end

-- Function to remove Ping counter
function removePingCounter()
    if game.CoreGui:FindFirstChild("PingCounter") then
        game.CoreGui.PingCounter:Destroy()
    end
end

local Players = game:FindFirstChildOfClass("Players") or game:GetService("Players")

local staffUserIds = {
    15941965, 20349956, 130576147, 1089013506, 361635460, 17850664, 478882362,
    133321104, 583533194, 113947873, 171835162, 1945168488, 754154414,
    102231521, 581580645, 787266546
}

local function TeleportToDifferentServer()
    local HttpService = game:GetService("HttpService")
    local TeleportService = game:GetService("TeleportService")
    local PlaceId = game.PlaceId

    local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
    local serverList = {}

    for _, server in ipairs(servers.data) do
        if server.playing < server.maxPlayers and server.id ~= game.JobId then
            table.insert(serverList, server.id)
        end
    end

    if #serverList > 0 then
        local serverId = serverList[math.random(1, #serverList)]
        TeleportService:TeleportToPlaceInstance(PlaceId, serverId, Players.LocalPlayer)
    else
        print("No available servers to hop to.")
    end
end

local function checkStaffInGame()
    for _, player in ipairs(Players:GetPlayers()) do
        if table.find(staffUserIds, player.UserId) then
            return true
        end
    end
    return false
end

local function createStaffNotificationGui()
    local ScreenGui = Instance.new("ScreenGui")
    local Frame = Instance.new("Frame")
    local Title = Instance.new("TextLabel")
    local YesButton = Instance.new("TextButton")
    local NoButton = Instance.new("TextButton")

    ScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

    Frame.Size = UDim2.new(0, 200, 0, 100) -- Adjusted size
    Frame.Position = UDim2.new(0, 10, 1, -110) -- Start at bottom left with 10px margin and 10px above the bottom
    Frame.BackgroundColor3 = Color3.new(0, 0, 0) -- Black background
    Frame.Parent = ScreenGui

    Title.Size = UDim2.new(1, 0, 0.3, 0)
    Title.Text = "A Staff/Dev is in your server. Would you like to server hop?"
    Title.TextColor3 = Color3.new(1, 1, 1) -- White text
    Title.TextScaled = true -- Text scaled
    Title.Parent = Frame

    YesButton.Size = UDim2.new(1, 0, 0.3, 0)
    YesButton.Position = UDim2.new(0, 0, 0.3, 0)
    YesButton.Text = "Yes"
    YesButton.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2) -- Dark gray background
    YesButton.TextColor3 = Color3.new(1, 1, 1) -- White text
    YesButton.Parent = Frame
    YesButton.MouseButton1Click:Connect(function()
        ScreenGui:Destroy()
        TeleportToDifferentServer()
    end)

    NoButton.Size = UDim2.new(1, 0, 0.3, 0)
    NoButton.Position = UDim2.new(0, 0, 0.6, 0)
    NoButton.Text = "No"
    NoButton.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2) -- Dark gray background
    NoButton.TextColor3 = Color3.new(1, 1, 1) -- White text
    NoButton.Parent = Frame
    NoButton.MouseButton1Click:Connect(function()
        ScreenGui:Destroy()
    end)
end

local staffNotifyActive = false
local autoHopActive = false

MiscTab:CreateToggle({
    Name = "Staff Notify",
    Info = {
        Title = 'Staff Notify',
        Image = '12735851647',
        Description = 'Notifies you when a staff joins your server and gives you options',
    },
    CurrentValue = false,
    Flag = "NotifyWhenStaffJoin",
    Callback = function(Value)
        staffNotifyActive = Value
        if Value then
            while staffNotifyActive do
                if checkStaffInGame() then
                    createStaffNotificationGui()
                    break
                end
                wait(5)
            end
        end
    end,
})

MiscTab:CreateToggle({
    Name = "Auto Server Hop When Staff Joins",
    Info = {
        Title = 'Auto Server Hop When Staff Joins',
        Image = '12735851647',
        Description = 'Automatically Joins A New Server When A Staff Joins. Dont Recommend This On',
    },
    CurrentValue = false,
    Flag = "AutoHopWhenStaffJoin",
    Callback = function(Value)
        autoHopActive = Value
        if Value then
            while autoHopActive do
                if checkStaffInGame() then
                    TeleportToDifferentServer()
                    break
                end
                wait(5)
            end
        end
    end,
})

local function serverHop()
    local HttpService = game:GetService("HttpService")
    local TeleportService = game:GetService("TeleportService")
    local player = game:GetService("Players").LocalPlayer

    local servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100")).data
    local randomServer = servers[math.random(1, #servers)]

    TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer.id, player)
end

MiscTab:CreateButton({
    Name = "Server Hop",
    Info = {
        Title = 'Server Hop',
        Description = 'makes you join a different Server',
    },
    Interact = 'Changable',
    Callback = serverHop,
})

MiscTab:CreateButton({
    Name = "Rejoin",
    Info = {
        Title = 'Rejoin',
        Description = 'Makes You Rejoin The Current Server Your In',
    },
    Interact = 'Changable',
    Callback = function()
        local TeleportService = game:GetService("TeleportService")
        local placeId = game.PlaceId
        local jobId = game.JobId

        TeleportService:TeleportToPlaceInstance(placeId, jobId)
    end,
})
local GunTab = Window:CreateTab("Gun", 4483362458) -- Title, Image

local cim = require(game:GetService("Players").LocalPlayer.PlayerScripts.Modules.ClientReplicatedClasses.ClientFighter.ClientItem)
local inputFunc = cim.Input
local old

local function modifyValues()
    old = hookfunction(inputFunc, function(...)
        local args = {...}
        if type(args[1]) == "table" then
            -- Modify the values
            args[1].Info.ShootRecoil = 0
            args[1].Info.ShootSpread = 0
            args[1].Info.ProjectileSpeed = 99999999
            args[1].Info.ShootCooldown = 0
            args[1].Info.QuickShotCooldown = 0
        end

        return old(...)
    end)
end

local Button = GunTab:CreateButton({
    Name = "Op Gun",
    Info = {
        Title = 'Op Gun',
        Description = 'Makes All Your Weapons Op',
    },
    Interact = 'Changable',
    Callback = function()
        modifyValues()
        print('Modifications Activated')
    end,
})

local camera = game.Workspace.CurrentCamera
local originalFOV = camera.FieldOfView -- Store the original FOV
local fovValue = 10 -- Default slider value

local WorldTab = Window:CreateTab("World Tab", 4483362458) -- Title, Image

-- Button to apply the FOV change
WorldTab:CreateButton({
    Name = "Apply Fov",
    Info = {
        Title = 'Apply Fov',
        Description = 'Applys the Fov you put in the slider',
    },
    Interact = 'SkibidiToilet',
    Callback = function()
        camera.FieldOfView = fovValue
        print("Fov changed to " .. fovValue)
    end,
})

-- Slider to adjust the FOV value
WorldTab:CreateSlider({
    Name = "Fov Slider",
    Range = {0, 1000},
    Increment = 1,
    Suffix = "Fov",
    CurrentValue = 65,
    Flag = "FovSlider",
    Callback = function(Value)
        fovValue = Value
    end,
})

local skyThemes = {
    ["Twilight"] = {
        SkyboxBk = "rbxassetid://264908339",
        SkyboxDn = "rbxassetid://264907909",
        SkyboxFt = "rbxassetid://264909420",
        SkyboxLf = "rbxassetid://264909758",
        SkyboxRt = "rbxassetid://264908886",
        SkyboxUp = "rbxassetid://264907379",
    },
    ["Nebula"] = {
        SkyboxBk = "rbxassetid://159454299",
        SkyboxDn = "rbxassetid://159454296",
        SkyboxFt = "rbxassetid://159454293",
        SkyboxLf = "rbxassetid://159454286",
        SkyboxRt = "rbxassetid://159454300",
        SkyboxUp = "rbxassetid://159454288",
    },
    ["Vaporwave"] = {
        SkyboxBk = "rbxassetid://1417494030",
        SkyboxDn = "rbxassetid://1417494146",
        SkyboxFt = "rbxassetid://1417494253",
        SkyboxLf = "rbxassetid://1417494402",
        SkyboxRt = "rbxassetid://1417494499",
        SkyboxUp = "rbxassetid://1417494643",
    },
    ["Redshift"] = {
        SkyboxBk = "rbxassetid://401664839",
        SkyboxDn = "rbxassetid://401664862",
        SkyboxFt = "rbxassetid://401664960",
        SkyboxLf = "rbxassetid://401664881",
        SkyboxRt = "rbxassetid://401664901",
        SkyboxUp = "rbxassetid://401664936",
    },
    ["Blue Stars"] = {
        SkyboxBk = "rbxassetid://149397684",
        SkyboxDn = "rbxassetid://149397686",
        SkyboxFt = "rbxassetid://149397688",
        SkyboxLf = "rbxassetid://149397692",
        SkyboxRt = "rbxassetid://149397697",
        SkyboxUp = "rbxassetid://149397702",
    },
    ["Blue Aurora"] = {
        SkyboxBk = "rbxassetid://12063984",
        SkyboxDn = "rbxassetid://12064107",
        SkyboxFt = "rbxassetid://12064152",
        SkyboxLf = "rbxassetid://12064121",
        SkyboxRt = "rbxassetid://12064115",
        SkyboxUp = "rbxassetid://12064131",
    }
}

local selectedOption = "Default" -- Default option

WorldTab:CreateDropdown({
    Name = "Sky Theme",
    Options = {"Default", "Rinns Hub Sky", "Twilight", "Nebula", "Vaporwave", "Redshift", "Blue Stars", "Blue Aurora"},
    CurrentOption = "Default",
    MultiSelection = false,
    Flag = "SkyDrop",
    Callback = function(Option)
        selectedOption = Option
        print(Option)
    end,
})

WorldTab:CreateButton({
    Name = "Apply Sky Theme",
    Info = {
        Title = 'Apply Sky Theme',
        Description = 'Applies The Selected Sky Theme',
    },
    Interact = 'Changable',
    Callback = function()
        local lighting = game:GetService("Lighting")
        local sky = lighting:FindFirstChildOfClass("Sky")

        if sky then
            if selectedOption == "Default" then
                sky.SkyboxUp = "rbxassetid://14147881297"
                sky.SkyboxRt = "rbxassetid://14147882405"
                sky.SkyboxLf = "rbxassetid://14147883091"
                sky.SkyboxFt = "rbxassetid://14147882761"
                sky.SkyboxDn = "rbxassetid://14147882149"
                sky.SkyboxBk = "rbxassetid://14147881792"
            elseif selectedOption == "Rinns Hub Sky" then
                sky.SkyboxUp = "rbxassetid://18962850396"
                sky.SkyboxRt = "rbxassetid://18962850396"
                sky.SkyboxLf = "rbxassetid://18962850396"
                sky.SkyboxFt = "rbxassetid://18962850396"
                sky.SkyboxDn = "rbxassetid://18962850396"
                sky.SkyboxBk = "rbxassetid://18962850396"
            elseif skyThemes[selectedOption] then
                sky.SkyboxUp = skyThemes[selectedOption].SkyboxUp
                sky.SkyboxRt = skyThemes[selectedOption].SkyboxRt
                sky.SkyboxLf = skyThemes[selectedOption].SkyboxLf
                sky.SkyboxFt = skyThemes[selectedOption].SkyboxFt
                sky.SkyboxDn = skyThemes[selectedOption].SkyboxDn
                sky.SkyboxBk = skyThemes[selectedOption].SkyboxBk
            end
            print('Sky theme applied: ' .. selectedOption)
        else
            print("No Sky object found in Lighting.")
        end
    end,
})


local weaponSkins = {
    ["Bow"] = {"Compound Bow", "Raven Bow"},
    ["Assault Rifle"] = {"AK-47", "AUG"},
    ["Chainsaw"] = {"Blobsaw", "Handsaws"},
    ["RPG"] = {"Nuke Launcher", "RPKEY", "Spaceship Launcher"},
    ["Burst Rifle"] = {"Aqua Burst", "Electro Rifle"},
    ["Exogun"] = {"Singularity", "Wondergun"},
    ["Fists"] = {"Boxing Gloves", "Brass Knuckles"},
    ["Flamethrower"] = {"Lamethrower", "Pixel Flamethrower"},
    ["Flare Gun"] = {"Dynamite Gun", "Firework Gun"},
    ["Freeze Ray"] = {"Bubble Ray", "Temporal Ray"},
    ["Grenade"] = {"Water Balloon", "Whoopee Cushion"},
    ["Grenade Launcher"] = {"Swashbuckler", "Uranium Launcher"},
    ["Handgun"] = {"Blaster"},
    ["Katana"] = {"Lightning Bolt", "Saber"},
    ["Minigun"] = {"Lasergun 3000", "Pixel Minigun"},
    ["Paintball Gun"] = {"Boba Gun", "Slime Gun"},
    ["Revolver"] = {"Sheriff"},
    ["Slingshot"] = {"Goalpost", "Stick"},
    ["Subspace Tripmine"] = {"Don't Press", "Spring"},
    ["Uzi"] = {"Electro Uzi", "Water Uzi"},
    ["Sniper"] = {"Pixel Sniper", "Hyper Sniper"},
    ["Knife"] = {"Karambit", "Chancla"},
}

local selectedSkins = {}
local assetFolder = game:GetService("Players").LocalPlayer.PlayerScripts.Assets.ViewModels
local Functions = {}

function Functions:swapWeaponSkins(normalWeaponName, skinName)
    local normalWeapon = assetFolder:FindFirstChild(normalWeaponName)
    if not normalWeapon then return end

    if skinName and skinName ~= "" then
        local skin = assetFolder:FindFirstChild(skinName)
        if not skin then return end

        normalWeapon:ClearAllChildren()
        for _, child in ipairs(skin:GetChildren()) do
            local newChild = child:Clone()
            newChild.Parent = normalWeapon
        end
    end
end

-- Creating dropdowns and button
for weaponName, skins in pairs(weaponSkins) do
    GunTab:CreateDropdown({
        Name = weaponName .. " Skins",
        Options = skins,
        CurrentOption = "",
        MultiSelection = false,
        Flag = weaponName .. "Dropdown",
        Callback = function(selectedSkin)
            selectedSkins[weaponName] = selectedSkin
        end,
    })
end

GunTab:CreateButton({
    Name = "Apply Selected Skins",
    Info = {
        Title = 'Apply Skins',
        Description = 'Applies the selected skins to the respective weapons.',
    },
    Interact = 'Changable',
    Callback = function()
        for weaponName, selectedSkin in pairs(selectedSkins) do
            Functions:swapWeaponSkins(weaponName, selectedSkin)
        end
    end,
})

local silentAimEnabled = false

Tab:CreateToggle({
    Name = "Silent Aim",
    Info = {
        Title = 'Silent Aim',
        Image = '12735851647',
        Description = 'Idk What To Put Here Tbh But You Get The Name',
    },
    CurrentValue = false,
    Flag = "ToggleSilentAim", 
    Callback = function(Value)
        silentAimEnabled = Value
        print("Silent Aim Enabled: ", silentAimEnabled)
    end,
})

local players = game:GetService("Players")
local run_service = game:GetService("RunService")
local replicated_storage = game:GetService("ReplicatedStorage")
local user_input_service = game:GetService("UserInputService")

local camera = workspace.CurrentCamera
local localplayer = players.LocalPlayer
local playerscripts = localplayer.PlayerScripts
local aa_rotation = 0

local camera_controller = require(playerscripts.Controllers.CameraController)
local constants = require(replicated_storage.Modules.CONSTANTS)
local fighter_controller = require(playerscripts.Controllers.FighterController)
local mechanics_controller = require(playerscripts.Controllers.MechanicsController)

local storage = {closest_player = nil}
local funcs = {}

funcs.get_players = function() 
    local player_list = {}

    for _, object in workspace:GetChildren() do
        if (object.Name:find("Dummy") or players:GetPlayerFromCharacter(object) and object.Name ~= localplayer.Name) then
            player_list[#player_list + 1] = object
        elseif object.Name == "HurtEffect" then
            for _, hurt_player in object:GetChildren() do
                player_list[#player_list + 1] = hurt_player
            end
        end
    end

    return player_list
end

funcs.get_closest_player = function()
    local closest, closest_distance = nil, math.huge

    for _, player in funcs.get_players() do
        if player:FindFirstChild("HumanoidRootPart") then
            local w2s, onscreen = camera:WorldToViewportPoint(player.HumanoidRootPart.Position)
            local distance = (Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2) - Vector2.new(w2s.X, w2s.Y)).Magnitude

            if onscreen and distance < closest_distance then
                closest = player
                closest_distance = distance
            end
        end
    end

    return closest
end

funcs.get_weapon = function(fighter)
    return fighter.EquippedItem
end

funcs.get_fighter = function(player)
    return fighter_controller:GetFighter(player)
end

funcs.calculate_prediction = function(origin_pos, end_pos, end_velocity, bullet_speed)
    local distance = (origin_pos - end_pos).Magnitude
    local travel_time = distance / bullet_speed
    return end_velocity * travel_time
end

camera_controller:SetPOV(false, 0, false)

local render_stepped; render_stepped = run_service.RenderStepped:Connect(function()
    if silentAimEnabled then
        -- Update closest player
        storage.closest_player = funcs.get_closest_player()
        
        -- Removed camera movement to the predicted position
    end
end)

local old_namecall; old_namecall = hookmetamethod(game, "__namecall", function(self, ...)
    if silentAimEnabled then
        local arguments = {...}
        local namecall_method = getnamecallmethod()
        local weapon = funcs.get_weapon(funcs.get_fighter(players.LocalPlayer))

        if namecall_method == "ViewportPointToRay" then
            if weapon and weapon.Info and weapon.Info.ProjectileSpeed then
                local closest_player = storage.closest_player
                local rootpart = closest_player and closest_player:FindFirstChild("HumanoidRootPart")
                if rootpart and weapon.ViewModel and weapon.ViewModel._body_model then
                    local origin_pos = weapon.ViewModel._body_model.BodyPrimary.Position
                    local end_pos = closest_player:FindFirstChild("Head") and closest_player.Head.Position or rootpart.Position
                    local predicted_velocity = funcs.calculate_prediction(origin_pos, end_pos, rootpart.Velocity, weapon.Info.ProjectileSpeed) or Vector3.zero
                    local predicted_pos = end_pos + Vector3.new(predicted_velocity.X, 0, predicted_velocity.Z)
                    return Ray.new(origin_pos, (predicted_pos - origin_pos).Unit)
                end
            end

        elseif namecall_method == "FireServer" and self.Name == "UseItem" then
            if typeof(arguments[3]) == "table" and weapon and weapon.Info.Type then
                arguments[3]["\2"] = (weapon.Info.Type ~= "Melee")
            end
        end
    end

    return old_namecall(self, ...)
end)

local old_upd_rotation; old_upd_rotation = hookfunction(mechanics_controller._UpdateCharacterRotation, function(self)
    if silentAimEnabled then
        return old_upd_rotation(self)
    end
end)

print("Script loaded successfully")
ArrayField:LoadConfiguration()
