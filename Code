local ArrayField = loadstring(game:HttpGet("https://raw.githubusercontent.com/Hosvile/Refinement/main/MC%3AArrayfield%20Library"))()

if not ArrayField then
    error("Failed to load ArrayField library")
end

local Window = ArrayField:CreateWindow({
    Name = "Rinns Hub Rivals",
    LoadingTitle = "Rinns Hub Rivals",
    LoadingSubtitle = "Code By Rinn Ui by Sirius Ui remake by Hosvile",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "RinnsHubConfigs",
        FileName = "RinnsHubRivals"
    },
    Discord = {
        Enabled = true,
        Invite = "pzZTWgkUgE",
        RememberJoins = false
    },
    KeySystem = false,
    KeySettings = {
        Title = "ArrayField",
        Subtitle = "Key System",
        Note = "Join the discord (discord.gg/sirius)",
        FileName = "ArrayFieldsKeys",
        SaveKey = false,
        GrabKeyFromSite = false,
        Key = {"Hello", "Bye"},
        Actions = {
            [1] = {
                Text = 'Click here to copy the key link',
                OnPress = function() end,
            }
        },
    }
})

local Tab = Window:CreateTab("Main Tab", 4483362458)

-- Aimbot settings
local aimbotEnabled = false
local wallCheckEnabled = false
local aimbotFov = 175
local fovTransparency = 0.4
local fovThickness = 2
local lockOnRange = 3000
local fovCircle = nil
local aimPart = "Head"
local fovFollowMouse = false
local players = game:GetService("Players")
local camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local wishlistedUsers = {}
local wishlistFriends = false
local fovCircleColor = Color3.new(1, 1, 1)

local function createFovCircle()
    if fovCircle then fovCircle:Remove() end
    fovCircle = Drawing.new("Circle")
    fovCircle.Thickness = fovThickness
    fovCircle.NumSides = 64
    fovCircle.Radius = aimbotFov
    fovCircle.Color = fovCircleColor
    fovCircle.Transparency = fovTransparency
    fovCircle.Visible = aimbotEnabled
end

local function updateFovCircle()
    if fovCircle then
        fovCircle.Position = fovFollowMouse and UserInputService:GetMouseLocation() or Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
        fovCircle.Radius = aimbotFov
        fovCircle.Color = fovCircleColor
        fovCircle.Transparency = fovTransparency
        fovCircle.Thickness = fovThickness
        fovCircle.Visible = aimbotEnabled
    end
end

local function isPlayerVisible(target)
    local origin = camera.CFrame.Position
    local _, onScreen = camera:WorldToScreenPoint(target.Position)
    if not onScreen then
        return false
    end

    local ray = Ray.new(origin, (target.Position - origin).unit * lockOnRange)
    local part, hitPosition = workspace:FindPartOnRayWithIgnoreList(ray, {camera, players.LocalPlayer.Character})
    if part and part:IsDescendantOf(target.Parent) then
        return true
    end

    return false
end

local function isUserWishlisted(username)
    for _, user in pairs(wishlistedUsers) do
        if string.find(string.lower(username), string.lower(user)) then
            return true
        end
    end
    return false
end

local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(players:GetPlayers()) do
        if player ~= players.LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = player.Character.HumanoidRootPart
            local humanoid = player.Character.Humanoid

            if humanoid.Health > 0 then
                local screenPoint = camera:WorldToScreenPoint(hrp.Position)
                local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - (fovFollowMouse and UserInputService:GetMouseLocation() or Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2))).Magnitude

                if distanceFromCenter <= aimbotFov and (not wallCheckEnabled or isPlayerVisible(hrp)) then
                    local distance = (hrp.Position - players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimAtClosestPlayer()
    if aimbotEnabled then
        local closestPlayer = getClosestPlayer()
        if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild(aimPart) then
            local target = closestPlayer.Character[aimPart]
            local targetPosition = target.Position
            local currentCameraPosition = camera.CFrame.Position
            local direction = (targetPosition - currentCameraPosition).unit
            local targetCameraCFrame = CFrame.new(currentCameraPosition, currentCameraPosition + direction)
            camera.CFrame = targetCameraCFrame
        end
    end
end

RunService.RenderStepped:Connect(function()
    updateFovCircle()
    aimAtClosestPlayer()
end)

-- Aimbot UI
Tab:CreateToggle({
    Name = "Aimbot",
    Info = {
        Title = 'Enable or Disable Aimbot',
        Description = 'Dont feel like typing all that but remember Dont hold fire spam the fire button',
    },
    CurrentValue = aimbotEnabled,
    Flag = "AimbotToggle",
    Callback = function(Value)
        aimbotEnabled = Value
        updateFovCircle()
    end,
})

Tab:CreateToggle({
    Name = "Aimbot Wall Check",
    Info = {
        Title = 'Enable or Disable Wall Check',
        Description = 'Checks If the person the aimbot is trying to lock on is behind a way and wont lock on to them',
    },
    CurrentValue = wallCheckEnabled,
    Flag = "WallCheckToggle",
    Callback = function(Value)
        wallCheckEnabled = Value
    end,
})

Tab:CreateToggle({
    Name = "Aimbot Fov Follow Mouse",
    Info = {
        Title = 'Enable or Disable Aimbot Fov Follow Mouse',
        Description = 'Makes It so the Aimbot Fov follows your Mouse Dont Use This For Mobile',
    },
    CurrentValue = fovFollowMouse,
    Flag = "FovFollowMouseToggle",
    Callback = function(Value)
        fovFollowMouse = Value
        updateFovCircle()
    end,
})

Tab:CreateSpacing(nil,5)

Tab:CreateSlider({
    Name = "Aimbot Fov Size",
    Info = {
        Title = 'Change The Aimbot Fov Size',
        Description = 'Lets you change the size of the aimbot Fov',
    },
    Range = {1, 1000},
    Increment = 1,
    Suffix = "Studs",
    CurrentValue = aimbotFov,
    Flag = "AimbotFovSlider",
    Callback = function(Value)
        aimbotFov = Value
        updateFovCircle()
    end,
})

Tab:CreateSlider({
    Name = "Aimbot Fov Transparency",
    Info = {
        Title = 'Change The Aimbot Fov Transparency',
        Description = 'Lets you change the transparency of the aimbot Fov',
    },
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = fovTransparency,
    Flag = "AimbotFovTransparencySlider",
    Callback = function(Value)
        fovTransparency = Value
        updateFovCircle()
    end,
})

local NotificationHolder = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Module.Lua"))()
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Client.Lua"))()

Notification:Notify(
    {Title = "Warning", Description = "If Your Seeing Thid The Script Did Not Load Properly This Is getting fixed"},
    {OutlineColor = Color3.fromRGB(80, 80, 80),Time = 10, Type = "option"},
    {Image = "http://www.roblox.com/asset/?id=6023426923", ImageColor = Color3.fromRGB(255, 84, 84), Callback = function(State) print(tostring(State)) end}
)

print("testing1")
Tab:CreateSlider({
    Name = "Aimbot Fov Thickness",
    Info = {
        Title = 'Change The Aimbot Fov Thickness',
        Description = 'Lets you change the thickness of the aimbot Fov',
    },
    Range = {1, 10},
    Increment = 0.1,
    Suffix = "",
    CurrentValue = fovThickness,
    Flag = "AimbotFovThicknessSlider",
    Callback = function(Value)
        fovThickness = Value
        updateFovCircle()
    end,
})

print("testing2")

Tab:CreateDropdown({
    Name = "Aimbot Aim Part",
    Info = {
        Title = 'Change The Aimbot Aim Part',
        Description = 'Lets you change the part of the target the aimbot aims at',
    },
    Options = {"Head", "Torso", "HumanoidRootPart"},
    CurrentOption = aimPart,
    Flag = "AimbotAimPartDropdown",
    Callback = function(Value)
        aimPart = Value
    end,
})

Tab:CreateSlider({
    Name = "Aimbot Lock On Range",
    Info = {
        Title = 'Change The Aimbot Lock On Range',
        Description = 'Lets you change the range at which the aimbot locks on to targets',
    },
    Range = {100, 10000},
    Increment = 100,
    Suffix = "Studs",
    CurrentValue = lockOnRange,
    Flag = "AimbotLockOnRangeSlider",
    Callback = function(Value)
        lockOnRange = Value
    end,
})

print("testing 3")

Tab:CreateKeybind({
    Name = "Aimbot Toggle Keybind",
    CurrentKeybind = "Q",
    HoldToInteract = false,
    Flag = "AimbotKeybind",
    Callback = function(Keybind)
        aimbotEnabled = not aimbotEnabled
        updateFovCircle()
    end,
})

-- Initialize FOV circle
createFovCircle()
print("testing4")

Tab:CreateSpacing(nil,10)
print("Script didn't load successfully")

Tab:CreateToggle({
    Name = "Wishlist Friends Only",
    Info = {
        Title = 'Wishlist Friends Only',
        Description = 'Toggle to only wishlist friends.',
    },
    CurrentValue = wishlistFriends,
    Flag = "WishlistFriendsToggle",
    Callback = function(Value)
        wishlistFriends = Value
        if wishlistFriends then
            local success, result = pcall(function()
                return players:GetFriendsAsync(players.LocalPlayer.UserId)
            end)
            if success then
                wishlistedUsers = {}
                for _, friend in pairs(result) do
                    table.insert(wishlistedUsers, friend.Username)
                end
            else
                print("Error fetching friends:", result)
            end
        end
    end,
})

Tab:CreateButton({
    Name = "Clear Wishlist",
    Info = {
        Title = 'Clear Wishlist',
        Description = 'Clears all users from the wishlist.',
    },
    Callback = function()
        wishlistedUsers = {}
    end,
})

-- Function to find the closest match for a username
local function findClosestUsername(input)
    local closestUsername = nil
    local closestDistance = math.huge

    for _, player in pairs(players:GetPlayers()) do
        local lowerInput = string.lower(input)
        local lowerName = string.lower(player.Name)
        local _, matches = string.gsub(lowerName, lowerInput, "")
        local distance = #lowerInput + #lowerName - 2 * matches
        if matches > 0 and distance < closestDistance then
            closestDistance = distance
            closestUsername = player.Name
        end
    end

    return closestUsername
end

-- Update wishlist to store closest matching usernames
Tab:CreateInput({
    Name = "Wishlist Users On Skibidi",
    PlaceholderText = "The Aimbot wont lock on wishlistedUsers put a comma to show different users",
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        wishlistedUsers = {}
        local userInput = string.split(Text, ",")
        for _, user in pairs(userInput) do
            user = user:match("^%s*(.-)%s*$") -- trim whitespace
            if user ~= "" then
                local closestMatch = findClosestUsername(user)
                if closestMatch then
                    table.insert(wishlistedUsers, closestMatch)
                end
            end
        end
    end,
})

Tab:CreateSpacing(nil, 10)

local AutoVoteMap = false
local selectedOption = "Arena"
local randomExecutor

-- Define the map actions
local mapActions = {
    ["Onyx"] = function()
        local args = { [1] = "Onyx" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Onyx")
    end,
    ["Construction"] = function()
        local args = { [1] = "Construction" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Construction")
    end,
    ["Shooting Range"] = function()
        local args = { [1] = "Shooting Range" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Shooting Range")
    end,
    ["Docks"] = function()
        local args = { [1] = "Docks" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Docks")
    end,
    ["Crossroads"] = function()
        local args = { [1] = "Crossroads" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Crossroads")
    end,
    ["Station"] = function()
        local args = { [1] = "Station" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Station")
    end,
    ["Big Crossroads"] = function()
        local args = { [1] = "Big Crossroads" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Big Crossroads")
    end,
    ["Backrooms"] = function()
        local args = { [1] = "Backrooms" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Backrooms")
    end,
    ["Arena"] = function()
        local args = { [1] = "Arena" }
        game:GetService("ReplicatedStorage").Remotes.Duels.VoteMap:FireServer(unpack(args))
        print("Voted for Arena")
    end,
}

-- Create the toggle for Auto Vote Map
Tab:CreateToggle({
    Name = "Auto Vote Map",
    Info = {
        Title = 'Auto Vote Map',
        Image = '12735851647',
        Description = 'Automatically votes the selected map in the dropdown below for you',
    },
    CurrentValue = false,
    Flag = "AutoVote", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        AutoVoteMap = Value
        if AutoVoteMap then
            print("Auto Vote Map enabled")
        else
            print("Auto Vote Map disabled")
        end
    end,
})

-- Create the dropdown for map selection
Tab:CreateDropdown({
    Name = "Map Selector",
    Options = {"Onyx", "Construction", "Shooting Range", "Docks", "Crossroads", "Station", "Big Crossroads", "Backrooms", "Arena"},
    CurrentOption = "Arena",
    MultiSelection = false,
    Flag = "MapDropDown",
    Callback = function(Option)
        selectedOption = Option
        print("Selected map: " .. Option)
    end,
})

local MiscTab = Window:CreateTab("Misc Tab", 4483362458) -- Title, Image

local function getPlayerViewModels()
    local player = game.Players.LocalPlayer
    local viewModels = workspace:FindFirstChild("ViewModels")
    local playerViewModels = {}

    if viewModels then
        for _, child in pairs(viewModels:GetChildren()) do
            if string.find(child.Name, player.Name) then
                table.insert(playerViewModels, child)
            end
        end
    end

    return playerViewModels
end

local function applyRainbowEffect(part)
    local runService = game:GetService("RunService")
    local connection

    connection = runService.RenderStepped:Connect(function()
        local hue = tick() % 5 / 5
        local color = Color3.fromHSV(hue, 1, 1)
        for _, child in pairs(part:GetChildren()) do
            if child:IsA("BasePart") then
                child.Color = color
            end
        end
    end)

    return connection
end

local function applyRainbowToItem(item)
    local connections = {}

    local body = item:FindFirstChild("ItemVisual"):FindFirstChild("Body")
    local magazine = item:FindFirstChild("ItemVisual"):FindFirstChild("Magazine")

    if body then
        table.insert(connections, applyRainbowEffect(body))
    end

    if magazine then
        table.insert(connections, applyRainbowEffect(magazine))
    end

    return connections
end

local function stopRainbowEffect(connections)
    for _, connection in pairs(connections) do
        if typeof(connection) == "RBXScriptConnection" then
            connection:Disconnect()
        end
    end
end

local originalColors = {}

local function saveOriginalColors(item)
    local itemVisual = item:FindFirstChild("ItemVisual")
    if itemVisual then
        local body = itemVisual:FindFirstChild("Body")
        local magazine = itemVisual:FindFirstChild("Magazine")

        if body then
            for _, part in pairs(body:GetChildren()) do
                if part:IsA("BasePart") then
                    originalColors[part] = part.Color
                end
            end
        end

        if magazine then
            for _, part in pairs(magazine:GetChildren()) do
                if part:IsA("BasePart") then
                    originalColors[part] = part.Color
                end
            end
        end
    end
end

local function restoreOriginalColors()
    for part, color in pairs(originalColors) do
        if part then
            part.Color = color
        end
    end
end

local rainbowConnections = {}
local rainbowEnabled = false
local currentColor = Color3.fromRGB(2, 255, 255)
local currentTransparency = 0

local function updateRainbowEffect()
    if not rainbowEnabled then
        stopRainbowEffect(rainbowConnections)
        restoreOriginalColors()
        rainbowConnections = {}
    else
        local viewModels = getPlayerViewModels()
        for _, viewModel in pairs(viewModels) do
            saveOriginalColors(viewModel)
            local itemConnections = applyRainbowToItem(viewModel)
            for _, conn in pairs(itemConnections) do
                table.insert(rainbowConnections, conn)
            end
        end
    end
end

local function updateColor()
    if not rainbowEnabled then
        local viewModels = getPlayerViewModels()
        for _, viewModel in pairs(viewModels) do
            local itemVisual = viewModel:FindFirstChild("ItemVisual")
            if itemVisual then
                local body = itemVisual:FindFirstChild("Body")
                local magazine = itemVisual:FindFirstChild("Magazine")

                if body then
                    for _, part in pairs(body:GetChildren()) do
                        if part:IsA("BasePart") then
                            part.Color = currentColor
                        end
                    end
                end

                if magazine then
                    for _, part in pairs(magazine:GetChildren()) do
                        if part:IsA("BasePart") then
                            part.Color = currentColor
                        end
                    end
                end
            end
        end
    end
end

local function updateTransparency()
    local viewModels = getPlayerViewModels()
    for _, viewModel in pairs(viewModels) do
        local itemVisual = viewModel:FindFirstChild("ItemVisual")
        if itemVisual then
            local body = itemVisual:FindFirstChild("Body")
            local magazine = itemVisual:FindFirstChild("Magazine")

            if body then
                for _, part in pairs(body:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.Transparency = currentTransparency
                    end
                end
            end

            if magazine then
                for _, part in pairs(magazine:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.Transparency = currentTransparency
                    end
                end
            end
        end
    end
end

MiscTab:CreateToggle({
    Name = "Rainbow Weapon",
    Info = {
        Title = 'Rainbow Weapon',
        Image = '12735851647',
        Description = 'Makes your weapon transition rainbow so epic',
    },
    CurrentValue = false,
    Flag = "RainbowWeapon",
    Callback = function(Value)
        rainbowEnabled = Value
        if Value then
            updateRainbowEffect()
        else
            stopRainbowEffect(rainbowConnections)
            restoreOriginalColors()
            updateColor()
            updateTransparency()
        end
    end,
})

MiscTab:CreateSpacing(nil,10)

MiscTab:CreateColorPicker({
    Name = "Weapon Color Picker",
    Color = Color3.fromRGB(2, 255, 255),
    Flag = "WeaponColorPicker",
    Callback = function(Value)
        currentColor = Value
        if not rainbowEnabled then
            updateColor()
        end
    end,
})

MiscTab:CreateSlider({
    Name = "Weapon Transparency",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "Transparent",
    CurrentValue = 0,
    Flag = "WeaponTransSlider",
    Callback = function(Value)
        currentTransparency = Value
        updateTransparency()
    end,
})

game:GetService("RunService").RenderStepped:Connect(function()
    if rainbowEnabled then
        updateRainbowEffect()
    end
end)

local PlayerTab = Window:CreateTab("Players Tab", 4483362458) -- Title, Image

PlayerTab:CreateSpacing(nil,10)

local enableLongJump = false
local enableScytheDash = false
local enableClickTeleport = false

local function createLongJumpButton()
    if game.CoreGui:FindFirstChild("LongJumpGui") then
        return
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "LongJumpGui"
    screenGui.Parent = game.CoreGui

    local longJumpButton = Instance.new("TextButton")
    longJumpButton.Size = UDim2.new(0, 50, 0, 50)
    longJumpButton.Position = UDim2.new(1, -60, 0.5, -25)
    longJumpButton.Text = "Jump"
    longJumpButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    longJumpButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    longJumpButton.BackgroundTransparency = 0.5

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(1, 0)
    uiCorner.Parent = longJumpButton

    longJumpButton.Draggable = true
    longJumpButton.Active = true

    longJumpButton.MouseButton1Click:Connect(function()
        if enableLongJump then
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame * CFrame.new(0, 50, 0)}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end)

    longJumpButton.Parent = screenGui
end

local function createScytheDashButton()
    if game.CoreGui:FindFirstChild("ScytheDashGui") then
        return
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ScytheDashGui"
    screenGui.Parent = game.CoreGui

    local scytheDashButton = Instance.new("TextButton")
    scytheDashButton.Size = UDim2.new(0, 50, 0, 50)
    scytheDashButton.Position = UDim2.new(0, 10, 0.5, -25)
    scytheDashButton.Text = "Dash"
    scytheDashButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    scytheDashButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    scytheDashButton.BackgroundTransparency = 0.5

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(1, 0)
    uiCorner.Parent = scytheDashButton

    scytheDashButton.Draggable = true
    scytheDashButton.Active = true

    local function dash()
        if enableScytheDash then
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if rootPart and humanoid then
                    local camera = workspace.CurrentCamera
                    local lookVector = camera.CFrame.LookVector
                    local dashDirection = lookVector.Unit * 30 -- Ensure the lookVector is normalized
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame + dashDirection}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end

    scytheDashButton.MouseButton1Click:Connect(dash)

    scytheDashButton.Parent = screenGui
end

local function enableClickTeleportFunction()
    local player = game.Players.LocalPlayer
    local mouse = player:GetMouse()
    
    mouse.Button1Down:Connect(function()
        if enableClickTeleport then
            local character = player.Character or player.CharacterAdded:Wait()
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                rootPart.CFrame = CFrame.new(mouse.Hit.p + Vector3.new(0, 3, 0))
            end
        end
    end)
end

PlayerTab:CreateToggle({
    Name = "Fake Scythe Dash",
    Info = {
        Title = 'Enable Fake Scythe Dash',
        Image = '12735851647',
        Description = 'Lets You Dash it looks like the Scythe Dash',
    },
    CurrentValue = false,
    Flag = "EnableScytheDash", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        enableScytheDash = Value
    end,
})

PlayerTab:CreateToggle({
    Name = "Show Fake Scythe Dash Button",
    Info = {
        Title = 'Show Fake Scythe Dash Button',
        Image = '12735851647',
        Description = 'Shows the Fake Scythe Dash button Recommend Using This For Mobile',
    },
    CurrentValue = false,
    Flag = "ShowScytheDashButton", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value then
            createScytheDashButton()
        else
            local gui = game.CoreGui:FindFirstChild("ScytheDashGui")
            if gui then
                gui:Destroy()
            end
        end
        print(Value)
    end,
})

PlayerTab:CreateKeybind({
    Name = "Fake Scythe Dash Keybind",
    CurrentKeybind = "S",
    HoldToInteract = false,
    Flag = "ScytheDashKeybind",
    Callback = function(Keybind)
        if enableScytheDash then
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if rootPart and humanoid then
                    local camera = workspace.CurrentCamera
                    local lookVector = camera.CFrame.LookVector
                    local dashDirection = lookVector.Unit * 30 -- Ensure the lookVector is normalized
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame + dashDirection}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end,
})

PlayerTab:CreateSpacing(nil,10)

PlayerTab:CreateToggle({
    Name = "Long Jump",
    Info = {
        Title = 'Long Jump',
        Image = '12735851647',
        Description = 'Lets You long jump',
    },
    CurrentValue = false,
    Flag = "EnableLongJump", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        enableLongJump = Value
    end,
})

PlayerTab:CreateToggle({
    Name = "Show Long Jump Button",
    Info = {
        Title = 'Show Long Jump Button',
        Image = '12735851647',
        Description = 'Shows the Long Jump button Recommend using this for mobile',
    },
    CurrentValue = false,
    Flag = "ShowLongJumpButton", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value then
            createLongJumpButton()
        else
            local gui = game.CoreGui:FindFirstChild("LongJumpGui")
            if gui then
                gui:Destroy()
            end
        end
        print(Value)
    end,
})

PlayerTab:CreateKeybind({
    Name = "Long Jump Keybind",
    CurrentKeybind = "L",
    HoldToInteract = false,
    Flag = "LongJumpKeybind",
    Callback = function(Keybind)
        if enableLongJump then
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local tweenService = game:GetService("TweenService")
                    local info = TweenInfo.new(0.2, Enum.EasingStyle.Linear)
                    local goal = {CFrame = rootPart.CFrame * CFrame.new(0, 50, 0)}
                    local tween = tweenService:Create(rootPart, info, goal)
                    tween:Play()
                end
            end
        end
    end,
})

PlayerTab:CreateToggle({
    Name = "Click Teleport",
    Info = {
        Title = 'Click Teleport',
        Image = '12735851647',
        Description = 'Lets You Teleport Where You Click',
    },
    CurrentValue = false,
    Flag = "EnableClickTeleport", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        enableClickTeleport = Value
        if enableClickTeleport then
            enableClickTeleportFunction()
        end
    end,
})

PlayerTab:CreateSlider({
    Name = "WalkSpeed",
    Range = {0, 500},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 16,
    Flag = "WalkSpeedSlider",
    Callback = function(Value)
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = Value
        end
    end,
})

PlayerTab:CreateSlider({
    Name = "JumpPower",
    Range = {16, 500},
    Increment = 1,
    Suffix = "Power",
    CurrentValue = 50,
    Flag = "JumpPowerSlider",
    Callback = function(Value)
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.JumpPower = Value
        end
    end,
})
local NotificationHolder = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Module.Lua"))()
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Client.Lua"))()

Notification:Notify(
    {Title = "Opening Tabs", Description = "Click The Button On the Top Left To Open Tabs"},
    {OutlineColor = Color3.fromRGB(80, 80, 80),Time = 9, Type = "option"},
    {Image = "http://www.roblox.com/asset/?id=6023426923", ImageColor = Color3.fromRGB(255, 84, 84), Callback = function(State) print(tostring(State)) end}
)

print("Script loaded successfully")
